============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\config\database.php
============================
<?php

class Database
{
    private $host = "localhost";
    private $db_name = "ProBarberSystem";
    private $username = "root";
    private $password = "";
    private $conn;

    public function getConnection()
    {
        $this->conn = null;

        try {
            $this->conn = new PDO(
                "mysql:host={$this->host};dbname={$this->db_name};charset=utf8mb4",
                $this->username,
                $this->password
            );

            //  ConfiguraciÃ³n profesional de PDO
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // excepciones
            $this->conn->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); // fetch limpio
            $this->conn->setAttribute(PDO::ATTR_EMULATE_PREPARES, false); // seguridad total en prepared statements

        } catch (PDOException $e) {
            //  Nunca mostrar errores sensibles en producciÃ³n
            die(" Error de conexiÃ³n a la base de datos: " . $e->getMessage());
        }

        return $this->conn;
    }
}


============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\config\JWTConfig.php
============================
<?php
// ===============================================
// CONFIGURACIÃ“N DE JWT - CLAVE FIJA
// ===============================================

// CLAVE FIJA - NO CAMBIAR UNA VEZ EN PRODUCCIÃ“N
define("JWT_SECRET_KEY", "ProBarberSystem_MiClaveSecreta_2025_NoModificar_XyZ789");

// Constantes de tiempo
define("JWT_DURACION_SEGUNDOS", 60 * 24 * 60 * 60); // 60 dÃ­as
define("JWT_EMISOR", "ProBarberSystem");
define("JWT_AUDIENCIA", "ProBarberClients");

// IMPORTANTE: 
// - NO cambiar JWT_SECRET_KEY despuÃ©s de que usuarios hayan iniciado sesiÃ³n
// - Si la cambias, todos los tokens antiguos dejarÃ¡n de funcionar
// - Los usuarios tendrÃ¡n que volver a iniciar sesiÃ³n
?>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\controllers\BarberoController.php
============================
<?php
require_once __DIR__ . '/../config/database.php';
require_once __DIR__ . '/../middleware/AuthMiddleware.php';

class BarberoController
{
    private $db;

    public function __construct($dbConnection)
    {
        $this->db = $dbConnection;
        header("Content-Type: application/json; charset=UTF-8");
    }

    /**
     * Obtener todas las citas de una fecha especÃ­fica
     */
    public function obtenerCitasPorFecha()
    {
        // Verificar que el usuario es barbero
        $usuarioData = AuthMiddleware::verificarToken();
        
        if (!isset($usuarioData->rol) || $usuarioData->rol !== 'admin') {
            http_response_code(403);
            echo json_encode([
                "success" => false,
                "error" => "Acceso denegado. Solo barberos pueden acceder."
            ]);
            return;
        }

        $fecha = $_GET['fecha'] ?? date('Y-m-d');

        try {
            $stmt = $this->db->prepare("
                SELECT 
                    c.id,
                    c.fecha,
                    c.hora,
                    c.estado,
                    c.tipo_servicio,
                    c.nombre_cliente,
                    c.telefono_cliente,
                    cl.email,
                    cl.notas
                FROM citas c
                LEFT JOIN clientes cl ON c.cliente_id = cl.id
                WHERE c.fecha = :fecha
                ORDER BY c.hora ASC
            ");

            $stmt->execute([':fecha' => $fecha]);
            $citas = $stmt->fetchAll(PDO::FETCH_ASSOC);

            // EstadÃ­sticas del dÃ­a
            $total = count($citas);
            $pendientes = 0;
            $realizadas = 0;
            $canceladas = 0;

            foreach ($citas as $cita) {
                switch ($cita['estado']) {
                    case 'pendiente':
                        $pendientes++;
                        break;
                    case 'realizada':
                        $realizadas++;
                        break;
                    case 'cancelada':
                        $canceladas++;
                        break;
                }
            }

            echo json_encode([
                "success" => true,
                "citas" => $citas,
                "estadisticas" => [
                    "total" => $total,
                    "pendientes" => $pendientes,
                    "realizadas" => $realizadas,
                    "canceladas" => $canceladas
                ]
            ]);

        } catch (PDOException $e) {
            http_response_code(500);
            echo json_encode([
                "success" => false,
                "error" => "Error al obtener citas: " . $e->getMessage()
            ]);
        }
    }

    /**
     * Marcar cita como realizada
     */
    public function marcarComoRealizada()
    {
        $usuarioData = AuthMiddleware::verificarToken();
        
        if (!isset($usuarioData->rol) || $usuarioData->rol !== 'admin') {
            http_response_code(403);
            echo json_encode([
                "success" => false,
                "error" => "Acceso denegado"
            ]);
            return;
        }

        $data = json_decode(file_get_contents("php://input"), true);

        if (!isset($data['cita_id'])) {
            http_response_code(400);
            echo json_encode([
                "success" => false,
                "error" => "ID de cita no proporcionado"
            ]);
            return;
        }

        try {
            $stmt = $this->db->prepare("
                UPDATE citas 
                SET estado = 'realizada' 
                WHERE id = :cita_id AND estado = 'pendiente'
            ");

            if ($stmt->execute([':cita_id' => $data['cita_id']])) {
                echo json_encode([
                    "success" => true,
                    "message" => "Cita marcada como realizada"
                ]);
            } else {
                http_response_code(400);
                echo json_encode([
                    "success" => false,
                    "error" => "No se pudo actualizar la cita"
                ]);
            }

        } catch (PDOException $e) {
            http_response_code(500);
            echo json_encode([
                "success" => false,
                "error" => "Error: " . $e->getMessage()
            ]);
        }
    }

    /**
     * Obtener resumen semanal
     */
    public function obtenerResumenSemanal()
    {
        $usuarioData = AuthMiddleware::verificarToken();
        
        if (!isset($usuarioData->rol) || $usuarioData->rol !== 'admin') {
            http_response_code(403);
            echo json_encode(["success" => false, "error" => "Acceso denegado"]);
            return;
        }

        try {
            // Obtener lunes y domingo de la semana actual
            $hoy = new DateTime();
            $diaSemana = $hoy->format('N'); // 1 (lunes) a 7 (domingo)
            $lunes = clone $hoy;
            $lunes->modify('-' . ($diaSemana - 1) . ' days');
            $domingo = clone $lunes;
            $domingo->modify('+6 days');

            $stmt = $this->db->prepare("
                SELECT 
                    DATE(fecha) as dia,
                    COUNT(*) as total_citas,
                    SUM(CASE WHEN estado = 'pendiente' THEN 1 ELSE 0 END) as pendientes,
                    SUM(CASE WHEN estado = 'realizada' THEN 1 ELSE 0 END) as realizadas
                FROM citas
                WHERE fecha BETWEEN :lunes AND :domingo
                GROUP BY DATE(fecha)
                ORDER BY fecha ASC
            ");

            $stmt->execute([
                ':lunes' => $lunes->format('Y-m-d'),
                ':domingo' => $domingo->format('Y-m-d')
            ]);

            $resumen = $stmt->fetchAll(PDO::FETCH_ASSOC);

            echo json_encode([
                "success" => true,
                "resumen" => $resumen,
                "rango" => [
                    "inicio" => $lunes->format('Y-m-d'),
                    "fin" => $domingo->format('Y-m-d')
                ]
            ]);

        } catch (PDOException $e) {
            http_response_code(500);
            echo json_encode([
                "success" => false,
                "error" => "Error: " . $e->getMessage()
            ]);
        }
    }
}
?>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\controllers\UsuariosController.php
============================
<?php
require_once __DIR__ . '/../models/Usuario.php';
require_once __DIR__ . '/../config/JWTConfig.php';

use Firebase\JWT\JWT;

class UsuarioController
{
    private $db;
    private $usuarioModel;

    public function __construct($dbConnection)
    {
        $this->db = $dbConnection;
        $this->usuarioModel = new Usuario($dbConnection);
        header("Content-Type: application/json; charset=UTF-8");
    }

    // ======================
    // Registro
    // ======================
    public function registrar()
    {
        $data = json_decode(file_get_contents("php://input"), true);

        if (!$data || !isset($data["nombre"], $data["email"], $data["password"], $data["telefono"])) {
            http_response_code(400);
            echo json_encode(["error" => "Datos incompletos"]);
            return;
        }

        if (!filter_var($data["email"], FILTER_VALIDATE_EMAIL)) {
            http_response_code(400);
            echo json_encode(["error" => "Email invÃ¡lido"]);
            return;
        }

        if ($this->usuarioModel->verificarEmail($data["email"])) {
            http_response_code(409);
            echo json_encode(["error" => "Este email ya estÃ¡ registrado"]);
            return;
        }

        // Insertar usuario
        $usuarioData = [
            'nombre'    => htmlspecialchars($data['nombre']),
            'apellidos' => htmlspecialchars($data['apellidos'] ?? ''),
            'telefono'  => $data['telefono'] ?? '',
            'email'     => strtolower($data['email']),
            'password'  => $data['password'],
            'rol'       => 'usuario'
        ];

        if (!$this->usuarioModel->crearUsuario($usuarioData)) {
            http_response_code(500);
            echo json_encode(["error" => "Error al crear usuario"]);
            return;
        }

        $usuario_id = $this->db->lastInsertId();
        if (!$usuario_id) {
            http_response_code(500);
            echo json_encode(["error" => "No se pudo obtener el usuario_id"]);
            return;
        }

        // Insertar cliente
        $stmt = $this->db->prepare("INSERT INTO clientes (nombre, telefono, email) VALUES (:nombre, :telefono, :email)");
        if (!$stmt->execute([
            ':nombre' => $usuarioData['nombre'],
            ':telefono' => $usuarioData['telefono'],
            ':email' => $usuarioData['email']
        ])) {
            http_response_code(500);
            echo json_encode(["error" => "No se pudo crear el cliente"]);
            return;
        }

        $cliente_id = $this->db->lastInsertId();
        if (!$cliente_id) {
            http_response_code(500);
            echo json_encode(["error" => "No se pudo obtener el cliente_id"]);
            return;
        }

        // ACTUALIZAR usuarios.cliente_id
        $stmtUpdate = $this->db->prepare("UPDATE usuarios SET cliente_id = :cliente_id WHERE id = :usuario_id");
        $stmtUpdate->execute([
            ':cliente_id' => $cliente_id,
            ':usuario_id' => $usuario_id
        ]);

        // Crear JWT con cliente_id Y rol
        $payload = [
            "iss" => "ProBarberSystem",
            "aud" => "ProBarberClients",
            "iat" => time(),
            "exp" => time() + (60 * 24 * 60 * 60), 
            "data" => [
                "id" => $usuario_id,
                "cliente_id" => $cliente_id,
                "nombre" => $usuarioData["nombre"],
                "apellidos" => $usuarioData["apellidos"],
                "email" => $usuarioData["email"],
                "rol" => "usuario" // 
            ]
        ];

        $jwt = JWT::encode($payload, JWT_SECRET_KEY, 'HS256');

        echo json_encode([
            "mensaje" => "Usuario registrado correctamente",
            "token" => $jwt,
            "usuario" => [
                "id" => $usuario_id,
                "cliente_id" => $cliente_id,
                "nombre" => $usuarioData["nombre"],
                "apellidos" => $usuarioData["apellidos"],
                "email" => $usuarioData["email"],
                "rol" => "usuario"
            ]
        ]);
    }

    // ======================
    // Login (CORREGIDO)
    // ======================
    public function login()
    {
        $data = json_decode(file_get_contents("php://input"), true);

        if (!isset($data["email"], $data["password"])) {
            http_response_code(400);
            echo json_encode(["error" => "Datos incompletos"]);
            return;
        }

        $usuario = $this->usuarioModel->login($data["email"], $data["password"]);
        if (!$usuario) {
            http_response_code(401);
            echo json_encode(["error" => "Credenciales incorrectas"]);
            return;
        }

        // BUSCAR O CREAR cliente_id automÃ¡ticamente
        $stmt = $this->db->prepare("SELECT id FROM clientes WHERE email = :email LIMIT 1");
        $stmt->execute([':email' => $usuario['email']]);
        $cliente = $stmt->fetch(PDO::FETCH_ASSOC);
        
        $cliente_id = null;

        if ($cliente) {
            // Cliente ya existe
            $cliente_id = $cliente['id'];
        } else {
            // Cliente NO existe, lo creamos automÃ¡ticamente
            $stmtInsert = $this->db->prepare(
                "INSERT INTO clientes (nombre, telefono, email, notas) 
                 VALUES (:nombre, :telefono, :email, :notas)"
            );
            
            $nombreCompleto = trim($usuario['nombre'] . ' ' . ($usuario['apellidos'] ?? ''));
            
            $stmtInsert->execute([
                ':nombre' => $nombreCompleto,
                ':telefono' => $usuario['telefono'] ?? '',
                ':email' => $usuario['email'],
                ':notas' => 'Cliente creado automÃ¡ticamente al hacer login'
            ]);

            $cliente_id = $this->db->lastInsertId();
            
            if (!$cliente_id) {
                http_response_code(500);
                echo json_encode(["error" => "No se pudo crear el cliente automÃ¡ticamente"]);
                return;
            }
        }

        if (!$cliente_id) {
            http_response_code(500);
            echo json_encode(["error" => "No se encontrÃ³ cliente_id para este usuario"]);
            return;
        }

        // ACTUALIZAR usuarios.cliente_id si no lo tiene
        if (!isset($usuario['cliente_id']) || $usuario['cliente_id'] != $cliente_id) {
            $stmtUpdate = $this->db->prepare("UPDATE usuarios SET cliente_id = :cliente_id WHERE id = :usuario_id");
            $stmtUpdate->execute([
                ':cliente_id' => $cliente_id,
                ':usuario_id' => $usuario['id']
            ]);
        }

        // JWT con cliente_id Y rol garantizados
        $payload = [
            "iss" => "ProBarberSystem",
            "aud" => "ProBarberClients",
            "iat" => time(),
            "exp" => time() + (60 * 24 * 60 * 60), 
            "data" => [
                "id" => $usuario["id"],
                "cliente_id" => $cliente_id,
                "nombre" => $usuario["nombre"],
                "apellidos" => $usuario["apellidos"] ?? '',
                "email" => $usuario["email"],
                "rol" => $usuario["rol"] ?? "usuario" 
            ]
        ];

        $jwt = JWT::encode($payload, JWT_SECRET_KEY, 'HS256');

        echo json_encode([
            "mensaje" => "Login correcto",
            "token" => $jwt,
            "usuario" => [
                "id" => $usuario["id"],
                "cliente_id" => $cliente_id,
                "nombre" => $usuario["nombre"],
                "apellidos" => $usuario["apellidos"] ?? '',
                "email" => $usuario["email"],
                "rol" => $usuario["rol"] ?? "usuario"
            ]
        ]);
    }
}
?>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\middleware\AuthMiddleware.php
============================
<?php

require_once __DIR__ . '/../config/JWTConfig.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Firebase\JWT\ExpiredException;

class AuthMiddleware
{
    public static function verificarToken()
    {
        $headers = getallheaders();

        if (!isset($headers["Authorization"])) {
            http_response_code(401);
            echo json_encode([
                "error" => "Token no proporcionado",
                "codigo" => "TOKEN_MISSING"
            ]);
            exit;
        }

        $token = str_replace("Bearer ", "", $headers["Authorization"]);

        try {
            $decoded = JWT::decode($token, new Key(JWT_SECRET_KEY, 'HS256'));
            
            // Registrar Ãºltimo acceso (opcional, para estadÃ­sticas)
            error_log("âœ… Token vÃ¡lido - Usuario ID: " . $decoded->data->id);
            
            return $decoded->data;
            
        } catch (ExpiredException $e) {
            http_response_code(401);
            echo json_encode([
                "error" => "Token expirado",
                "codigo" => "TOKEN_EXPIRED",
                "mensaje" => "Tu sesiÃ³n ha expirado por inactividad. Por favor, inicia sesiÃ³n nuevamente."
            ]);
            exit;
            
        } catch (Exception $e) {
            http_response_code(401);
            echo json_encode([
                "error" => "Token invÃ¡lido",
                "codigo" => "TOKEN_INVALID",
                "mensaje" => "Token corrupto o manipulado"
            ]);
            exit;
        }
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\models\Cita.php
============================
<?php
class Cita {
    private $db;

    public function __construct($dbConnection) {
        $this->db = $dbConnection;
    }

    public function crearCita($data): bool {
        // Primero, obtener el nombre del servicio
        $stmtServicio = $this->db->prepare("SELECT nombre FROM servicios WHERE id = :servicio_id");
        $stmtServicio->execute([':servicio_id' => $data['servicio_id']]);
        $servicio = $stmtServicio->fetch(PDO::FETCH_ASSOC);
        $tipo_servicio = $servicio ? $servicio['nombre'] : 'Servicio desconocido';

        // Obtener datos del cliente
        $stmtCliente = $this->db->prepare("SELECT nombre, telefono FROM clientes WHERE id = :cliente_id");
        $stmtCliente->execute([':cliente_id' => $data['cliente_id']]);
        $cliente = $stmtCliente->fetch(PDO::FETCH_ASSOC);

        $sql = "INSERT INTO citas (fecha, hora, servicio_id, tipo_servicio, cliente_id, nombre_cliente, telefono_cliente)
                VALUES (:fecha, :hora, :servicio_id, :tipo_servicio, :cliente_id, :nombre_cliente, :telefono_cliente)";
        
        $stmt = $this->db->prepare($sql);
        return $stmt->execute([
            ':fecha' => $data['fecha'],
            ':hora' => $data['hora'],
            ':servicio_id' => $data['servicio_id'],
            ':tipo_servicio' => $tipo_servicio,
            ':cliente_id' => $data['cliente_id'],
            ':nombre_cliente' => $cliente['nombre'] ?? 'Desconocido',
            ':telefono_cliente' => $cliente['telefono'] ?? ''
        ]);
    }
}
?>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\models\Usuario.php
============================
<?php
class Usuario
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    // Crear usuario
    public function crearUsuario(array $data): bool
{
    if (empty($data['nombre']) || empty($data['email']) || empty($data['password'])) {
        return false;
    }

    $passwordHash = password_hash($data['password'], PASSWORD_DEFAULT);

    $sql = "INSERT INTO usuarios (nombre, apellidos, telefono, email, password, rol, fecha_registro)
            VALUES (:nombre, :apellidos, :telefono, :email, :password, :rol, NOW())";

    $query = $this->db->prepare($sql);
    return $query->execute([
        ':nombre'    => $data['nombre'],
        ':apellidos' => $data['apellidos'] ?? null,
        ':telefono'  => $data['telefono'],
        ':email'     => strtolower($data['email']),
        ':password'  => $passwordHash,
        ':rol'       => $data['rol'] ?? 'usuario'
    ]);
}


    // Verificar si un email ya existe
    public function verificarEmail(string $email): bool
    {
        $sql = "SELECT id FROM usuarios WHERE email = :email LIMIT 1";
        $query = $this->db->prepare($sql);
        $query->execute([':email' => strtolower($email)]);
        return (bool)$query->fetch();
    }

    // Login
    public function login(string $email, string $password): ?array
    {
        $sql = "SELECT * FROM usuarios WHERE email = :email LIMIT 1";
        $query = $this->db->prepare($sql);
        $query->execute([':email' => strtolower($email)]);
        $usuario = $query->fetch(PDO::FETCH_ASSOC);

        if (!$usuario) return null;

        if (password_verify($password, $usuario['password'])) {
            unset($usuario['password']); // Nunca devolver contraseÃ±a
            return $usuario;
        }

        return null;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\routes\api.php
============================

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\utils\jwt.php
============================

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\utils\response.php
============================

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\utils\security.php
============================

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\backend\index.php
============================
<?php
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Accept, Authorization');
header('Content-Type: application/json; charset=UTF-8');

// Manejar peticiones OPTIONS (preflight)
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

ob_start();
ini_set('display_errors', 0);
error_reporting(E_ALL);

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/config/database.php';
require_once __DIR__ . '/controllers/UsuariosController.php';
require_once __DIR__ . '/controllers/BarberoController.php';
require_once __DIR__ . '/middleware/AuthMiddleware.php';

// ConexiÃ³n a la base de datos
$db = (new Database())->getConnection();
$usuarioController = new UsuarioController($db);

// ===============================================
// FUNCIONES DE EMAIL
// ===============================================

/**
 * EnvÃ­a email de confirmaciÃ³n de cita
 */
function enviarEmailConfirmacion($db, $citaId) {
    try {
        // Obtener datos de la cita
        $stmt = $db->prepare("
            SELECT 
                c.fecha,
                c.hora,
                c.tipo_servicio,
                cl.nombre,
                cl.email
            FROM citas c
            INNER JOIN clientes cl ON c.cliente_id = cl.id
            WHERE c.id = :cita_id
        ");
        $stmt->execute([':cita_id' => $citaId]);
        $cita = $stmt->fetch(PDO::FETCH_ASSOC);
        
        if (!$cita) {
            error_log(" No se encontrÃ³ la cita ID: $citaId");
            return false;
        }
        
        // Formatear fecha y hora
        $fechaObj = new DateTime($cita['fecha']);
        $fechaFormateada = $fechaObj->format('d/m/Y');
        $horaFormateada = substr($cita['hora'], 0, 5);
        
        // ðŸ“§ CARGAR PLANTILLA HTML DESDE ARCHIVO EXTERNO
        $rutaPlantilla = __DIR__ . '/../pages/email_confirmacion.html';
        
        if (!file_exists($rutaPlantilla)) {
            error_log(" No se encontrÃ³ el archivo: $rutaPlantilla");
            return false;
        }
        
        $htmlTemplate = file_get_contents($rutaPlantilla);
        
        // Reemplazar placeholders con datos reales
        $mensaje = str_replace(
            ['{{NOMBRE}}', '{{FECHA}}', '{{HORA}}', '{{SERVICIO}}'],
            [$cita['nombre'], $fechaFormateada, $horaFormateada, $cita['tipo_servicio']],
            $htmlTemplate
        );
        
        // Configurar headers
        $headers = "MIME-Version: 1.0" . "\r\n";
        $headers .= "Content-type:text/html;charset=UTF-8" . "\r\n";
        $headers .= "From: ProBarberSystem <noreply@probarber.com>" . "\r\n";
        
        // Enviar email
        if (mail($cita['email'], " Cita Confirmada - ProBarberSystem", $mensaje, $headers)) {
            error_log(" Email de confirmaciÃ³n enviado a: {$cita['email']}");
            return true;
        }
        
        error_log(" Error al enviar email a: {$cita['email']}");
        return false;
        
    } catch (Exception $e) {
        error_log(" Error en enviarEmailConfirmacion: " . $e->getMessage());
        return false;
    }
}

/**
 * EnvÃ­a email de cancelaciÃ³n de cita
 */
function enviarEmailCancelacion($db, $citaId) {
    try {
        $stmt = $db->prepare("
            SELECT 
                c.fecha,
                c.hora,
                c.tipo_servicio,
                cl.nombre,
                cl.email
            FROM citas c
            INNER JOIN clientes cl ON c.cliente_id = cl.id
            WHERE c.id = :cita_id
        ");
        $stmt->execute([':cita_id' => $citaId]);
        $cita = $stmt->fetch(PDO::FETCH_ASSOC);
        
        if (!$cita) return false;
        
        $fechaObj = new DateTime($cita['fecha']);
        $fechaFormateada = $fechaObj->format('d/m/Y');
        $horaFormateada = substr($cita['hora'], 0, 5);
        
        //  CARGAR PLANTILLA HTML DESDE ARCHIVO EXTERNO
        $rutaPlantilla = __DIR__ . '/../pages/email_cancelacion.html';
        
        if (!file_exists($rutaPlantilla)) {
            error_log(" No se encontrÃ³ el archivo: $rutaPlantilla");
            return false;
        }
        
        $htmlTemplate = file_get_contents($rutaPlantilla);
        
        // Reemplazar placeholders
        $mensaje = str_replace(
            ['{{NOMBRE}}', '{{FECHA}}', '{{HORA}}', '{{SERVICIO}}'],
            [$cita['nombre'], $fechaFormateada, $horaFormateada, $cita['tipo_servicio']],
            $htmlTemplate
        );
        
        $headers = "MIME-Version: 1.0" . "\r\n";
        $headers .= "Content-type:text/html;charset=UTF-8" . "\r\n";
        $headers .= "From: ProBarberSystem <noreply@probarber.com>" . "\r\n";
        
        if (mail($cita['email'], " Cita Cancelada - ProBarberSystem", $mensaje, $headers)) {
            error_log(" Email de cancelaciÃ³n enviado a: {$cita['email']}");
            return true;
        }
        
        return false;
        
    } catch (Exception $e) {
        error_log(" Error en enviarEmailCancelacion: " . $e->getMessage());
        return false;
    }
}

// ===============================================
// SWITCH DE ACCIONES
// ===============================================

$action = $_GET['action'] ?? '';

switch($action) {

    // ----------------------
    // Registro de usuario
    // ----------------------
    case 'register':
        $usuarioController->registrar();
        break;

    // ----------------------
    // Login
    // ----------------------
    case 'login':
        $usuarioController->login();
        break;

    // ----------------------
    // Ruta protegida
    // ----------------------
    case 'perfil':
        $usuarioData = AuthMiddleware::verificarToken();
        ob_clean();
        echo json_encode([
            "mensaje" => "Ruta protegida funcionando",
            "usuario" => $usuarioData
        ]);
        break;

    // ----------------------
    // Reservar cita
    // ----------------------
    case 'reservar':
        try {
            $rawData = file_get_contents("php://input");
            $data = json_decode($rawData, true);
            
            if (json_last_error() !== JSON_ERROR_NONE) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "JSON invÃ¡lido: " . json_last_error_msg()
                ]);
                break;
            }

            // Validar campos requeridos
            $camposFaltantes = [];
            if (!isset($data['fecha'])) $camposFaltantes[] = 'fecha';
            if (!isset($data['hora'])) $camposFaltantes[] = 'hora';
            if (!isset($data['servicio_id'])) $camposFaltantes[] = 'servicio_id';
            if (!isset($data['cliente_id'])) $camposFaltantes[] = 'cliente_id';

            if (!empty($camposFaltantes)) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "Faltan estos campos: " . implode(', ', $camposFaltantes)
                ]);
                break;
            }

            // Validar que la fecha no sea pasada
            $fechaCita = new DateTime($data['fecha']);
            $hoy = new DateTime();
            $hoy->setTime(0, 0, 0);

            if ($fechaCita < $hoy) {
                http_response_code(400);
                ob_clean();
                echo json_encode(["success" => false, "error" => "No se pueden reservar citas en fechas pasadas"]);
                break;
            }

            // Validar formato de hora (HH:MM)
            if (!preg_match('/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/', $data['hora'])) {
                http_response_code(400);
                ob_clean();
                echo json_encode(["success" => false, "error" => "Formato de hora invÃ¡lido"]);
                break;
            }

            require_once __DIR__ . '/models/Cita.php';
            $citaModel = new Cita($db);

            // PrevenciÃ³n de cita duplicada
            $stmt = $db->prepare("SELECT COUNT(*) FROM citas WHERE fecha = :fecha AND hora = :hora AND estado != 'cancelada'");
            $stmt->execute([
                ':fecha' => $data['fecha'],
                ':hora' => $data['hora']
            ]);

            if ($stmt->fetchColumn() > 0) {
                http_response_code(409);
                ob_clean();
                echo json_encode(["success" => false, "error" => "Hora no disponible"]);
                break;
            }

            // Crear cita
            if ($citaModel->crearCita($data)) {
                $citaId = $db->lastInsertId();
                
                // Enviar email de confirmaciÃ³n
                enviarEmailConfirmacion($db, $citaId);

                ob_clean();
                echo json_encode(["success" => true, "message" => "Cita registrada correctamente"]);
            } else {
                http_response_code(500);
                ob_clean();
                echo json_encode(["success" => false, "error" => "No se pudo registrar la cita"]);
            }

        } catch (PDOException $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode(["success" => false, "error" => "Error de base de datos: " . $e->getMessage()]);
        } catch (Exception $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode(["success" => false, "error" => "ExcepciÃ³n: " . $e->getMessage()]);
        }
        break;
   
    // ----------------------
    // Obtener horas ocupadas por fecha
    // ----------------------
    case 'horas_ocupadas':
        $fecha = $_GET['fecha'] ?? null;

        if (!$fecha) {
            ob_clean();
            echo json_encode([
                "success" => false,
                "horas_ocupadas" => []
            ]);
            break;
        }

        try {
            $stmt = $db->prepare("
                SELECT hora
                FROM citas
                WHERE fecha = :fecha
                AND estado != 'cancelada'
            ");

            $stmt->execute([':fecha' => $fecha]);
            $horas = $stmt->fetchAll(PDO::FETCH_COLUMN);

            ob_clean();
            echo json_encode([
                "success" => true,
                "horas_ocupadas" => $horas
            ]);

        } catch (PDOException $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode([
                "success" => false,
                "horas_ocupadas" => [],
                "error" => $e->getMessage()
            ]);
        }
        break;

    // ----------------------
    // Obtener citas del usuario autenticado
    // ----------------------
    case 'mis_citas':
        try {
            $usuarioData = AuthMiddleware::verificarToken();
            
            if (!isset($usuarioData->cliente_id)) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "No se encontrÃ³ cliente_id en el token"
                ]);
                break;
            }
            
            $cliente_id = $usuarioData->cliente_id;
            
            $stmt = $db->prepare("
                SELECT
                    c.id,
                    c.fecha,
                    c.hora,
                    c.estado,
                    c.tipo_servicio,
                    c.servicio_id
                FROM citas c
                WHERE c.cliente_id = :cliente_id
                ORDER BY c.fecha DESC, c.hora DESC
            ");
            
            $stmt->execute([':cliente_id' => $cliente_id]);
            $citas = $stmt->fetchAll(PDO::FETCH_ASSOC);
            
            ob_clean();
            echo json_encode([
                'success' => true,
                'citas' => $citas
            ]);
            
        } catch (Exception $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode([
                'success' => false,
                'error' => 'Error al obtener citas: ' . $e->getMessage()
            ]);
        }
        break;

    // ----------------------
    // Cancelar cita
    // ----------------------
    case 'cancelar_cita':
        try {
            $usuarioData = AuthMiddleware::verificarToken();
            
            if (!isset($usuarioData->cliente_id)) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "No se encontrÃ³ cliente_id en el token"
                ]);
                break;
            }
            
            $cliente_id = $usuarioData->cliente_id;
            $data = json_decode(file_get_contents('php://input'), true);
            
            if (!isset($data['cita_id'])) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'ID de cita no proporcionado'
                ]);
                break;
            }
            
            $cita_id = intval($data['cita_id']);
            
            $stmt = $db->prepare("
                SELECT id, estado
                FROM citas
                WHERE id = :cita_id AND cliente_id = :cliente_id
            ");
            
            $stmt->execute([
                ':cita_id' => $cita_id,
                ':cliente_id' => $cliente_id
            ]);
            
            $cita = $stmt->fetch(PDO::FETCH_ASSOC);
            
            if (!$cita) {
                http_response_code(404);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Cita no encontrada o no pertenece a este usuario'
                ]);
                break;
            }
            
            if ($cita['estado'] !== 'pendiente') {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Solo se pueden cancelar citas en estado pendiente'
                ]);
                break;
            }
            
            $updateStmt = $db->prepare("
                UPDATE citas
                SET estado = 'cancelada'
                WHERE id = :cita_id
            ");
            
            if ($updateStmt->execute([':cita_id' => $cita_id])) {
                // Enviar email de cancelaciÃ³n
                enviarEmailCancelacion($db, $cita_id);

                ob_clean();
                echo json_encode([
                    'success' => true,
                    'message' => 'Cita cancelada correctamente'
                ]);
            } else {
                http_response_code(500);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Error al cancelar la cita'
                ]);
            }
            
        } catch (Exception $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode([
                'success' => false,
                'error' => 'Error al cancelar cita: ' . $e->getMessage()
            ]);
        }
        break;

    // ----------------------
    // Obtener perfil
    // ----------------------
    case 'obtener_perfil':
        try {
            $usuarioData = AuthMiddleware::verificarToken();
           
            if (!isset($usuarioData->id)) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "No se encontrÃ³ usuario_id en el token"
                ]);
                break;
            }
           
            $usuario_id = $usuarioData->id;
           
            $stmt = $db->prepare("
                SELECT
                    id,
                    nombre,
                    apellidos,
                    telefono,
                    email,
                    fecha_registro
                FROM usuarios
                WHERE id = :usuario_id
            ");
           
            $stmt->execute([':usuario_id' => $usuario_id]);
            $usuario = $stmt->fetch(PDO::FETCH_ASSOC);
           
            if (!$usuario) {
                http_response_code(404);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Usuario no encontrado'
                ]);
                break;
            }
           
            //  CONTAR SOLO CITAS ACTIVAS (sin canceladas)
            $stmtCitas = $db->prepare("
                SELECT COUNT(*) as total
                FROM citas
                WHERE cliente_id = :cliente_id
                AND estado != 'cancelada'
            ");
            $stmtCitas->execute([':cliente_id' => $usuarioData->cliente_id]);
            $totalCitas = $stmtCitas->fetch(PDO::FETCH_ASSOC)['total'];
           
            ob_clean();
            echo json_encode([
                'success' => true,
                'usuario' => [
                    'nombre' => $usuario['nombre'],
                    'apellidos' => $usuario['apellidos'],
                    'telefono' => $usuario['telefono'],
                    'email' => $usuario['email'],
                    'fecha_registro' => $usuario['fecha_registro'],
                    'total_citas' => $totalCitas
                ]
            ]);
           
        } catch (Exception $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode([
                'success' => false,
                'error' => 'Error al obtener perfil: ' . $e->getMessage()
            ]);
        }
        break;

    // ----------------------
    // Actualizar perfil
    // ----------------------
    case 'actualizar_perfil':
        try {
            $usuarioData = AuthMiddleware::verificarToken();
            
            if (!isset($usuarioData->id)) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    "success" => false,
                    "error" => "Token invÃ¡lido"
                ]);
                break;
            }
            
            $data = json_decode(file_get_contents('php://input'), true);
            
            if (!isset($data['nombre']) || !isset($data['telefono'])) {
                http_response_code(400);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Datos incompletos'
                ]);
                break;
            }
            
            $stmt = $db->prepare("
                UPDATE usuarios
                SET nombre = :nombre,
                    apellidos = :apellidos,
                    telefono = :telefono
                WHERE id = :usuario_id
            ");
            
            $resultado = $stmt->execute([
                ':nombre' => htmlspecialchars($data['nombre']),
                ':apellidos' => htmlspecialchars($data['apellidos'] ?? ''),
                ':telefono' => $data['telefono'],
                ':usuario_id' => $usuarioData->id
            ]);
            
            if ($resultado) {
                $stmtCliente = $db->prepare("
                    UPDATE clientes
                    SET nombre = :nombre,
                        telefono = :telefono
                    WHERE id = :cliente_id
                ");
                
                $nombreCompleto = trim($data['nombre'] . ' ' . ($data['apellidos'] ?? ''));
                
                $stmtCliente->execute([
                    ':nombre' => $nombreCompleto,
                    ':telefono' => $data['telefono'],
                    ':cliente_id' => $usuarioData->cliente_id
                ]);
                
                ob_clean();
                echo json_encode([
                    'success' => true,
                    'message' => 'Perfil actualizado correctamente'
                ]);
            } else {
                http_response_code(500);
                ob_clean();
                echo json_encode([
                    'success' => false,
                    'error' => 'Error al actualizar perfil'
                ]);
            }
            
        } catch (Exception $e) {
            http_response_code(500);
            ob_clean();
            echo json_encode([
                'success' => false,
                'error' => 'Error al actualizar perfil: ' . $e->getMessage()
            ]);
        }
        break;

    // ----------------------
    // Panel del Barbero
    // ----------------------
    case 'citas_por_fecha':
        $barberoController = new BarberoController($db);
        $barberoController->obtenerCitasPorFecha();
        break;

    case 'marcar_realizada':
        $barberoController = new BarberoController($db);
        $barberoController->marcarComoRealizada();
        break;

    case 'resumen_semanal':
        $barberoController = new BarberoController($db);
        $barberoController->obtenerResumenSemanal();
        break;

    // ----------------------
    // Ruta por defecto
    // ----------------------
    default:
        ob_clean();
        echo json_encode([
            "mensaje" => "API ProBarberSystem funcionando. Accede a /index.php?action=register o login."
        ]);
        break;
}
?>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\css\styles.css
============================

/* ==============================
   IMPORTAR FUENTES DE GOOGLE
================================ */
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

/* ==============================
   VARIABLES
================================ */
:root {
  --bg-gradient: linear-gradient(135deg, #2b0040, #3a005f);
  --card-bg: linear-gradient(180deg, #3a005f, #2b0040);
  --input-bg: rgba(255, 255, 255, 0.12);
  --accent: #c44bd6;
  --white: #ffffff;
  --text-soft: rgba(255, 255, 255, 0.85);

  --radius: 18px;
  --transition: 0.25s ease;
  
  /* ðŸ”¤ FUENTES CORREGIDAS */
  --font-main: 'Poppins', 'Segoe UI', Tahoma, sans-serif;
  --font-buttons: 'Poppins', 'Segoe UI', Tahoma, sans-serif;
}

/* ==============================
   RESET
================================ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* ==============================
   BODY
================================ */
body {
  min-height: 100vh;
  font-family: 'Poppins', 'Segoe UI', Tahoma, sans-serif;
  background: var(--bg-gradient);
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--white);
  overflow-y: auto;
  padding: 20px 0;
}

/* ==============================
   CONTENEDOR LOGIN / REGISTRO
================================ */
.auth-container {
  width: 100%;
  max-width: 420px;
  padding: 40px 34px;
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
  margin: 0 auto;
}

/* ==============================
   TÃTULO
================================ */
.auth-container h1 {
  text-align: center;
  margin-bottom: 30px;
  letter-spacing: 1px;
  font-size: 1.8rem;
  font-family: 'Poppins', sans-serif;
  font-weight: 700;
}

/* ==============================
   FORMULARIO
================================ */
.auth-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* ==============================
   INPUT CON ICONO
================================ */
.input-group {
  position: relative;
  width: 100%;
}

.input-group span {
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  width: 34px;
  height: 34px;
  background: var(--white);
  color: #5a0b7d;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1rem;
  pointer-events: none;
  z-index: 1;
}

.input-group input,
.input-group select {
  width: 100%;
  max-width: 100%;
  padding: 14px 16px 14px 60px;
  border-radius: 14px;
  border: none;
  background: var(--input-bg);
  color: var(--white);
  font-size: 0.95rem;
  box-sizing: border-box;
  font-family: 'Poppins', sans-serif;
}

/* FIX: Input tipo date en mÃ³viles */
.input-group input[type="date"] {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  min-height: 50px;
}

.input-group input::placeholder {
  color: var(--text-soft);
}

.input-group input:focus,
.input-group select:focus {
  outline: 2px solid var(--accent);
}

.input-group select option {
  color: #000;
}

.input-group select {
  appearance: none;
  cursor: pointer;
}

/* ==============================
   BOTONES - TIPOGRAFÃA POPPINS FORZADA
================================ */

button,
.btn,
.btn-primary,
.btn-secondary,
.btn-logout,
.btn-cancelar,
.btn-login,
.btn-register,
input[type="submit"],
input[type="button"],
a.btn {
  font-family: 'Poppins', 'Segoe UI', Tahoma, sans-serif !important;
  font-weight: 700 !important;
  border: none;
  cursor: pointer;
}

.btn-primary {
  margin-top: 10px;
  padding: 14px;
  background: linear-gradient(135deg, #b44cd9, #8b2fc9);
  border-radius: 14px;
  color: var(--white);
  letter-spacing: 3px;
  transition: var(--transition);
  width: 100%;
  text-transform: uppercase;
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
}

.btn-primary:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

/* ==============================
   MENSAJES
================================ */
.mensaje {
  margin-top: 18px;
  text-align: center;
  font-size: 0.9rem;
}

/* ==============================
   RESALTADO CAMPOS RESUMEN CITA
================================ */

#output > div {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 14px;
  padding: 16px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
}

#output strong {
  color: var(--accent);
  font-weight: 700;
}

#output > div p {
  font-size: 1rem;
}

#output > p {
  font-size: 0.85rem;
  opacity: 0.7;
  text-align: center;
}

#output h2 {
  margin-bottom: 24px;
  font-family: 'Poppins', sans-serif;
}

#output > div {
  margin-bottom: 24px;
}

#output > div p {
  margin-bottom: 3px;
}

#output > div p:last-child {
  margin-bottom: 0;
}

#output > p {
  margin-bottom: 20px;
}

#output {
  margin: 15px 0;
}

/* ==============================
   HOME - FIX COMPLETO
================================ */
body.home {
  min-height: 100vh;
  height: 100vh;
  width: 100%;
  margin: 0;
  padding: 0;

  font-family: 'Poppins', sans-serif;
  color: var(--white);

  background-image: url('../images/wallpaperhome.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: scroll;
  

  display: flex;
  justify-content: center;
  align-items: flex-end;

  overflow: hidden;
}

.home-container {
  width: 100%;
  max-width: 360px;
  margin: 0 auto;
  margin-bottom: 30px;
  padding: 20px 16px 32px;
  text-align: center;

  display: flex;
  flex-direction: column;
  align-items: center;
}

.buttons-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 14px;
  align-items: center;
}

.btn {
  width: 100%;
  max-width: 280px;
  padding: 12px 20px;
  font-size: 0.85rem;
  letter-spacing: 1.5px;
  border-radius: 14px;
  transition: all var(--transition);
  position: relative;
  overflow: hidden;
  text-decoration: none;
  display: inline-block;
  text-align: center;
  text-transform: uppercase;
}

.btn-login {
  background: linear-gradient(135deg, #c44bd6, #8b2fc9);
  color: var(--white);
  box-shadow: 0 10px 30px rgba(196, 75, 214, 0.5);
}

.btn-login:hover {
  transform: translateY(-3px);
  box-shadow: 0 15px 40px rgba(196, 75, 214, 0.7);
}

.btn-login:active {
  transform: translateY(-1px);
}

.btn-register {
  background: transparent;
  color: var(--white);
  border: 2px solid rgba(255, 255, 255, 0.3);
}

.btn-register:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--accent);
  transform: translateY(-3px);
}

.btn-register:active {
  transform: translateY(-1px);
}

.btn::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s ease, height 0.6s ease;
}

.btn:active::before {
  width: 300px;
  height: 300px;
}

/* ==============================
   HORAS - GRID
================================ */
.horas-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  margin-top: 10px;
  width: 100%;
}

.hora-btn {
  padding: 12px 0;
  text-align: center;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.15);
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
  user-select: none;
  position: relative;
  font-family: 'Poppins', sans-serif;
}

.hora-btn:hover {
  background: rgba(255, 255, 255, 0.25);
}

.hora-btn.selected {
  background: linear-gradient(135deg, #c44bd6, #8b2fc9);
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8) inset,
              0 8px 20px rgba(196, 75, 214, 0.6);
  transform: scale(1.08);
}

.hora-btn.selected::after {
  content: none;
}

.hora-btn.ocupada {
  opacity: 0.35;
  background: rgba(255, 255, 255, 0.08);
  cursor: not-allowed;
  color: rgba(255, 255, 255, 0.5);
}

/* ==============================
   TARJETAS DE CITAS
================================ */
#citasContainer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin: 20px 0;
}

.cita-card {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 14px;
  padding: 20px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.cita-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: linear-gradient(135deg, #c44bd6, #8b2fc9);
}

.cita-card:hover {
  transform: translateY(-2px);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35),
              0 8px 20px rgba(0, 0, 0, 0.3);
}

.cita-info p {
  margin-bottom: 10px;
  font-size: 0.95rem;
  line-height: 1.5;
}

.cita-info p:last-child {
  margin-bottom: 0;
}

.cita-info strong {
  color: var(--accent);
  font-weight: 700;
}

/* ==============================
   BADGES DE ESTADO
================================ */
.estado-badge {
  display: inline-block;
  padding: 6px 14px;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 0.5px;
  font-family: 'Poppins', sans-serif;
}

.estado-badge.pendiente {
  background: rgba(76, 175, 80, 0.22);
  color: #4caf50;
  border: 1px solid rgba(76, 175, 80, 0.45);
}

.estado-badge.realizada {
  background: rgba(33, 150, 243, 0.2);
  color: #2196f3;
  border: 1px solid rgba(33, 150, 243, 0.4);
}

.estado-badge.cancelada {
  background: rgba(244, 67, 54, 0.2);
  color: #f44336;
  border: 1px solid rgba(244, 67, 54, 0.4);
}

/* ==============================
   BOTÃ“N CANCELAR CITA
================================ */
.btn-cancelar {
  margin-top: 16px;
  padding: 12px 20px;
  width: 100%;
  background: rgba(244, 67, 54, 0.15);
  border: 1px solid rgba(244, 67, 54, 0.4);
  border-radius: 12px;
  color: #ff6b6b;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.25s ease;
  letter-spacing: 0.5px;
}

.btn-cancelar:hover {
  background: rgba(244, 67, 54, 0.25);
  border-color: #f44336;
  color: #ff5252;
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(244, 67, 54, 0.3);
}

.btn-cancelar:active {
  transform: translateY(0);
}

/* ==============================
   PERFIL DE USUARIO
================================ */

.perfil-info {
  display: flex;
  flex-direction: column;
  gap: 18px;
  margin-top: 20px;
}

.perfil-item {
  background: rgba(255, 255, 255, 0.12);
  border-radius: 14px;
  padding: 16px 20px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
  display: flex;
  flex-direction: column;
  gap: 8px;
  transition: all 0.3s ease;
}

.perfil-item:hover {
  background: rgba(255, 255, 255, 0.18);
  transform: translateX(4px);
}

.perfil-label {
  font-size: 0.85rem;
  opacity: 0.7;
  font-weight: 500;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

.perfil-value {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--white);
  word-break: break-word;
}

.btn-secondary {
  margin-top: 10px;
  padding: 14px;
  background: rgba(255, 255, 255, 0.12);
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 14px;
  color: var(--white);
  letter-spacing: 3px;
  transition: var(--transition);
  font-size: 0.9rem;
  width: 100%;
  text-transform: uppercase;
}

.btn-secondary:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: var(--accent);
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.btn-secondary:active {
  transform: translateY(0);
}

.btn-logout {
  padding: 14px;
  background: rgba(244, 67, 54, 0.15);
  border: 2px solid rgba(244, 67, 54, 0.4);
  border-radius: 14px;
  color: #ff6b6b;
  font-weight: 600;
  letter-spacing: 1.5px;
  transition: var(--transition);
  font-size: 0.9rem;
  width: 100%;
  text-transform: uppercase;
}

.btn-logout:hover {
  background: rgba(244, 67, 54, 0.25);
  border-color: #f44336;
  color: #ff5252;
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(244, 67, 54, 0.3);
}

.btn-logout:active {
  transform: translateY(0);
}

/* ===============================================
   PANEL DEL BARBERO - ESTILOS
=============================================== */

.panel-container {
  max-width: 900px;
  margin: 20px auto;
  padding: 20px;
}

/* ===============================================
   HEADER
=============================================== */
.panel-header {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 20px;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.header-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.header-top h1 {
  margin: 0;
  font-size: 1.8rem;
}

.btn-icon {
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 50%;
  width: 45px;
  height: 45px;
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.25s ease;
}

.btn-icon:hover {
  background: rgba(244, 67, 54, 0.2);
  transform: scale(1.1);
}

/* ===============================================
   SELECTOR DE FECHA
=============================================== */
.fecha-selector {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
}

.fecha-actual {
  flex: 1;
  display: flex;
  gap: 10px;
  align-items: center;
}

.input-fecha {
  flex: 1;
  padding: 12px 16px;
  border-radius: 12px;
  border: none;
  background: rgba(255, 255, 255, 0.12);
  color: var(--white);
  font-size: 1rem;
  font-family: var(--font-main);
  cursor: pointer;
}

.input-fecha::-webkit-calendar-picker-indicator {
  filter: invert(1);
  cursor: pointer;
}

.btn-hoy {
  padding: 12px 20px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s ease;
  font-family: var(--font-buttons);
}

.btn-hoy:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(196, 75, 214, 0.5);
}

.btn-nav {
  background: rgba(255, 255, 255, 0.12);
  border: none;
  border-radius: 50%;
  width: 45px;
  height: 45px;
  font-size: 1.2rem;
  cursor: pointer;
  transition: all 0.25s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-nav:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}

/* ===============================================
   ESTADÃSTICAS
=============================================== */
.estadisticas {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 12px;
}

.stat-card {
  background: rgba(255, 255, 255, 0.08);
  padding: 16px;
  border-radius: 12px;
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.15);
}

.stat-numero {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 4px;
  display: block;
}

.stat-label {
  font-size: 0.85rem;
  opacity: 0.8;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.stat-card.total .stat-numero { color: #2196f3; }
.stat-card.pendientes .stat-numero { color: #ffc107; }
.stat-card.realizadas .stat-numero { color: #4caf50; }
.stat-card.canceladas .stat-numero { color: #f44336; }

/* ===============================================
   LISTA DE CITAS
=============================================== */
.lista-citas {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.cita-barbero {
  background: var(--card-bg);
  border-radius: 14px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  border-left: 4px solid;
  transition: all 0.3s ease;
}

.cita-barbero.pendiente { border-left-color: #ffc107; }
.cita-barbero.realizada { border-left-color: #4caf50; }
.cita-barbero.cancelada { border-left-color: #f44336; opacity: 0.6; }

.cita-barbero:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.cita-hora {
  font-size: 1.8rem;
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--accent);
}

.cita-info-grid {
  display: grid;
  gap: 10px;
  margin-bottom: 16px;
}

.cita-info-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.cita-info-row strong {
  min-width: 90px;
  opacity: 0.7;
  font-size: 0.9rem;
}

.cita-info-row span {
  font-size: 1rem;
}

.telefono-link {
  color: var(--accent);
  text-decoration: none;
  font-weight: 600;
}

.telefono-link:hover {
  text-decoration: underline;
}

.cita-acciones {
  display: flex;
  gap: 10px;
  margin-top: 16px;
}

.btn-accion {
  flex: 1;
  padding: 12px;
  border: none;
  border-radius: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s ease;
  font-family: var(--font-buttons);
}

.btn-realizar {
  background: linear-gradient(135deg, #4caf50, #45a049);
  color: white;
}

.btn-realizar:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
}

.btn-realizar:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.mensaje-vacio {
  text-align: center;
  padding: 60px 20px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 14px;
  margin: 20px 0;
}

.mensaje-vacio-icono {
  font-size: 4rem;
  margin-bottom: 16px;
  opacity: 0.5;
}

.mensaje-vacio h3 {
  font-size: 1.3rem;
  margin-bottom: 8px;
}

.mensaje-vacio p {
  opacity: 0.7;
  font-size: 0.95rem;
}

/* ===============================================
   MODAL RESUMEN SEMANAL
=============================================== */
.modal {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: var(--card-bg);
  padding: 30px;
  border-radius: var(--radius);
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  position: relative;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
}

.close {
  position: absolute;
  right: 20px;
  top: 20px;
  font-size: 2rem;
  font-weight: bold;
  cursor: pointer;
  color: var(--white);
  opacity: 0.7;
  transition: opacity 0.25s ease;
}

.close:hover {
  opacity: 1;
}

.resumen-dia {
  background: rgba(255, 255, 255, 0.08);
  padding: 16px;
  border-radius: 12px;
  margin-bottom: 12px;
  border-left: 4px solid var(--accent);
}

.resumen-dia h4 {
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.resumen-stats {
  display: flex;
  gap: 16px;
  font-size: 0.9rem;
}

.resumen-stats span {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* ===============================================
   FOOTER
=============================================== */
.panel-footer {
  margin-top: 30px;
  text-align: center;
}

/* ===============================================
   RESPONSIVE
=============================================== */
@media (max-width: 600px) {
  .panel-container {
    padding: 10px;
  }

  .panel-header {
    padding: 16px;
  }

  .header-top h1 {
    font-size: 1.4rem;
  }

  .fecha-selector {
    flex-direction: column;
    gap: 10px;
  }

  .fecha-actual {
    width: 100%;
  }

  .estadisticas {
    grid-template-columns: repeat(2, 1fr);
  }

  .cita-hora {
    font-size: 1.5rem;
  }

  .cita-acciones {
    flex-direction: column;
  }

  .modal-content {
    width: 95%;
    padding: 20px;
  }
}

.loading {
  text-align: center;
  padding: 40px;
  opacity: 0.7;
}

/* ==============================
   RESPONSIVE
================================ */
@media (max-width: 480px) {
  body {
    padding: 10px 0;
  }

  .auth-container,
  .register-container {
    width: 95%;
    max-width: 360px;
    padding: 20px 16px;
    margin: 10px auto;
  }

  .auth-container h1 {
    font-size: 1.5rem;
  }

  .input-group input,
  .input-group select {
    font-size: 0.9rem;
    padding: 12px 14px 12px 55px;
  }

  .input-group span {
    width: 30px;
    height: 30px;
    left: 12px;
    font-size: 0.9rem;
  }

  .btn-primary,
  .btn-secondary,
  .btn-logout {
    padding: 12px;
    font-size: 0.85rem;
    letter-spacing: 2px;
  }

  .home-container {
    margin-bottom: 12px;
    padding: 20px 12px 24px;
  }

  .buttons-container {
    gap: 16px;
  }

  .btn {
    max-width: 100%;
    padding: 11px 18px;
  }

  .horas-grid {
    gap: 12px;
  }

  .hora-btn {
    padding: 10px 0;
    font-size: 0.9rem;
  }

  .perfil-info {
    gap: 14px;
  }

  .perfil-item {
    padding: 14px 16px;
  }

  .perfil-value {
    font-size: 1rem;
  }

  .cita-card {
    padding: 16px;
  }

  .cita-info p {
    font-size: 0.9rem;
  }

  /* FIX ESPECÃFICO FECHA MÃ“VIL */
  .input-group input[type="date"] {
    padding-left: 55px !important;
    padding-right: 14px !important;
    font-size: 0.9rem;
  }

  .input-group input[type="date"]::-webkit-calendar-picker-indicator {
    opacity: 0.6;
    cursor: pointer;
  }
}

@media (min-width: 768px) and (max-width: 1024px) {
  .auth-container {
    max-width: 500px;
    padding: 45px 40px;
  }
}

@media (min-width: 1025px) {
  body.home {
    align-items: flex-end;
  }

  .home-container {
    margin-bottom: 40px;
  }

  .auth-container {
    max-width: 480px;
  }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\auth.js
============================
// ===============================================
// INTERCEPTOR GLOBAL CON MANEJO DE SESIÃ“N
// ===============================================

/**
 * Verifica si el token estÃ¡ prÃ³ximo a expirar (menos de 7 dÃ­as)
 * y alerta al usuario para que renueve su sesiÃ³n
 */
function verificarProximaExpiracion(token) {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    const tiempoRestante = payload.exp - (Date.now() / 1000);
    const diasRestantes = Math.floor(tiempoRestante / (24 * 60 * 60));
    
    // Si quedan menos de 7 dÃ­as, mostrar notificaciÃ³n amigable
    if (diasRestantes > 0 && diasRestantes <= 7) {
      const ultimaAlerta = localStorage.getItem('ultimaAlertaExpiracion');
      const hoy = new Date().toDateString();
      
      // Solo mostrar una vez al dÃ­a
      if (ultimaAlerta !== hoy) {
        console.warn(`Tu sesiÃ³n expirarÃ¡ en ${diasRestantes} dÃ­as`);
        localStorage.setItem('ultimaAlertaExpiracion', hoy);
        
        // NotificaciÃ³n visual sutil (opcional)
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('ProBarberSystem', {
            body: `Tu sesiÃ³n expirarÃ¡ en ${diasRestantes} dÃ­as. Considera volver a iniciar sesiÃ³n.`,
            icon: '/images/icon-192.png'
          });
        }
      }
    }
  } catch (error) {
    console.error('Error verificando expiraciÃ³n:', error);
  }
}

/**
 * FunciÃ³n principal para hacer peticiones autenticadas
 */
async function fetchConAuth(url, options = {}) {
  const token = localStorage.getItem("jwtToken");
  
  // Si no hay token, redirigir a login
  if (!token) {
    console.warn('No hay token, redirigiendo a login');
    alert("Debes iniciar sesiÃ³n primero");
    window.location.href = "login.html";
    return null;
  }
  
  // Verificar proximidad de expiraciÃ³n
  verificarProximaExpiracion(token);
  
  // AÃ±adir token a los headers
  options.headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`,
    'Content-Type': options.headers?.['Content-Type'] || 'application/json'
  };
  
  try {
    const res = await fetch(url, options);
    
    // Manejo de token expirado o invÃ¡lido
    if (res.status === 401) {
      console.error('Token expirado o invÃ¡lido');
      
      // Limpiar datos de sesiÃ³n
      localStorage.removeItem("jwtToken");
      localStorage.removeItem("usuarioNombre");
      localStorage.removeItem("reserva");
      localStorage.removeItem("ultimaAlertaExpiracion");
      
      // Mensaje claro al usuario
      alert(
        "Tu sesiÃ³n ha expirado por inactividad.\n\n" +
        "Por seguridad, debes iniciar sesiÃ³n nuevamente.\n\n" +
        "Tus datos estÃ¡n seguros."
      );
      
      window.location.href = "login.html";
      return null;
    }
    
    // Manejo de errores de servidor
    if (!res.ok && res.status >= 500) {
      console.error('Error del servidor:', res.status);
      alert(
        "Error del servidor.\n\n" +
        "Por favor, intÃ©ntalo de nuevo en unos momentos."
      );
      return null;
    }
    
    return res;
    
  } catch (error) {
    console.error('Error de conexiÃ³n:', error);
    
    // Diferenciar entre error de red y otros errores
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      alert(
        "Error de conexiÃ³n.\n\n" +
        "Verifica tu conexiÃ³n a internet e intÃ©ntalo de nuevo."
      );
    } else {
      alert("Error inesperado. Por favor, intÃ©ntalo de nuevo.");
    }
    
    return null;
  }
}

/**
 * Verifica si hay sesiÃ³n activa al cargar cualquier pÃ¡gina protegida
 */
function verificarSesionActiva() {
  const token = localStorage.getItem("jwtToken");
  const paginasPublicas = ['home.html', 'login.html', 'register.html'];
  const paginaActual = window.location.pathname.split('/').pop();
  
  // Si es una pÃ¡gina pÃºblica, no hacer nada
  if (paginasPublicas.includes(paginaActual)) {
    return true;
  }
  
  // Si no hay token en pÃ¡gina protegida, redirigir
  if (!token) {
    console.warn('Acceso no autorizado a pÃ¡gina protegida');
    alert("Debes iniciar sesiÃ³n para acceder a esta pÃ¡gina");
    window.location.href = "login.html";
    return false;
  }
  
  // Verificar si el token estÃ¡ expirado
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    const ahora = Date.now() / 1000;
    
    if (payload.exp < ahora) {
      console.error('Token expirado detectado');
      localStorage.removeItem("jwtToken");
      localStorage.removeItem("usuarioNombre");
      localStorage.removeItem("reserva");
      
      alert(
        "Tu sesiÃ³n ha expirado.\n\n" +
        "Por favor, inicia sesiÃ³n nuevamente."
      );
      
      window.location.href = "login.html";
      return false;
    }
    
    console.log('SesiÃ³n vÃ¡lida');
    return true;
    
  } catch (error) {
    console.error('Token corrupto:', error);
    localStorage.removeItem("jwtToken");
    alert("Error de sesiÃ³n. Por favor, inicia sesiÃ³n nuevamente.");
    window.location.href = "login.html";
    return false;
  }
}

// ===============================================
// EXPORTAR FUNCIONES
// ===============================================

// Verificar sesiÃ³n automÃ¡ticamente al cargar la pÃ¡gina
document.addEventListener('DOMContentLoaded', () => {
  verificarSesionActiva();
});

// Hacer disponibles globalmente
window.fetchConAuth = fetchConAuth;
window.verificarSesionActiva = verificarSesionActiva;

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\config.js
============================
const backendURL = (() => {
  const hostname = location.hostname;
  
  // Desarrollo local
  if (hostname === "localhost" || 
      hostname === "127.0.0.1" || 
      hostname.startsWith("direccionIP") ||
      hostname.startsWith("10.") ||
      hostname.startsWith("172.")) {
    return `http://${hostname}/ProBarberSystem/backend/index.php`;
  }
  
  // ProducciÃ³n (con dominio real)
  return `https://${hostname}/backend/index.php`;
})();

console.log("Backend URL configurada:", backendURL);

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\login.js
============================
// ===============================================
// LOGIN CON REDIRECCIÃ“N POR ROL
// ===============================================

document.addEventListener('DOMContentLoaded', function() {
  console.log('âœ… Login page cargada');
  
  const form = document.getElementById('loginForm');
  
  // Verificar si ya hay sesiÃ³n activa
  const token = localStorage.getItem('jwtToken');
  if (token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      
      // Verificar si no estÃ¡ expirado
      if (payload.exp > Date.now() / 1000) {
        console.log('âœ… Ya hay sesiÃ³n activa, redirigiendo...');
        redirigirSegunRol(payload.data.rol);
        return;
      }
    } catch (error) {
      console.log('âš ï¸ Token invÃ¡lido, limpiando...');
      localStorage.clear();
    }
  }
  
  // Manejar envÃ­o del formulario
  if (form) {
    form.addEventListener('submit', function(e) {
      e.preventDefault();
      realizarLogin();
    });
  }
});

// ===============================================
// REALIZAR LOGIN
// ===============================================
function realizarLogin() {
  const email = document.getElementById('email').value.trim();
  const password = document.getElementById('password').value;
  const btnLogin = document.getElementById('btnLogin');
  
  // Validaciones
  if (!email || !password) {
    alert('âš ï¸ Por favor, completa todos los campos');
    return;
  }
  
  if (!email.includes('@')) {
    alert('âš ï¸ Email invÃ¡lido');
    return;
  }
  
  // Deshabilitar botÃ³n mientras se procesa
  if (btnLogin) {
    btnLogin.disabled = true;
    btnLogin.textContent = 'â³ Iniciando sesiÃ³n...';
  }
  
  console.log('ðŸ“¤ Enviando credenciales...');
  console.log('ðŸ“§ Email:', email);
  
  fetch(`${backendURL}?action=login`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ email, password })
  })
  .then(response => {
    console.log('ðŸ“¡ Respuesta recibida:', response.status);
    return response.json();
  })
  .then(data => {
    console.log('ðŸ“¦ Datos recibidos:', data);
    
    if (data.error) {
      throw new Error(data.error);
    }
    
    if (!data.token) {
      throw new Error('No se recibiÃ³ token del servidor');
    }
    
    // âœ… Guardar token y datos del usuario
    localStorage.setItem('jwtToken', data.token);
    localStorage.setItem('usuarioNombre', data.usuario.nombre);
    
    // Decodificar token para obtener el rol
    const payload = JSON.parse(atob(data.token.split('.')[1]));
    const rol = payload.data.rol || data.usuario.rol || 'usuario';
    
    console.log('âœ… Login exitoso');
    console.log('ðŸ‘¤ Usuario:', data.usuario.nombre);
    console.log('ðŸ”‘ Rol detectado:', rol);
    console.log('ðŸ“§ Email:', data.usuario.email);
    
    // Mostrar mensaje de Ã©xito
    // alert(`âœ… Â¡Bienvenido ${data.usuario.nombre}!`);
    
    // â­ REDIRECCIONAR SEGÃšN EL ROL
    redirigirSegunRol(rol);
    
  })
  .catch(error => {
    console.error('âŒ Error en login:', error);
    alert(`âŒ Error: ${error.message}`);
    
    // Rehabilitar botÃ³n
    if (btnLogin) {
      btnLogin.disabled = false;
      btnLogin.textContent = 'INICIAR SESIÃ“N';
    }
  });
}

// ===============================================
// REDIRECCIONAR SEGÃšN ROL
// ===============================================
function redirigirSegunRol(rol) {
  console.log('ðŸ”€ FunciÃ³n redirigirSegunRol llamada');
  console.log('ðŸ”‘ Rol recibido:', rol);
  
  // â­ SOLO admin va al panel del barbero
  if (rol === 'admin') {
    console.log('âž¡ï¸ Admin detectado â†’ Redirigiendo a panel_barbero.html');
    window.location.href = 'panel_barbero.html';
  } else {
    // Todos los demÃ¡s (usuario) van a mis_citas
    console.log('âž¡ï¸ Usuario normal â†’ Redirigiendo a mis_citas.html');
    window.location.href = 'mis_citas.html';
  }
}

console.log('âœ… login.js cargado');

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\mis_citas.js
============================
// Esperar a que el DOM estÃ© completamente cargado
window.addEventListener('DOMContentLoaded', function() {
  console.log("âœ… DOM cargado, iniciando...");
 
  const token = localStorage.getItem("jwtToken");
  console.log("ðŸ”‘ Token encontrado:", token ? "SÃ­" : "No");
 
  // Verificar sesiÃ³n
  if (!token) {
    alert("Debes iniciar sesiÃ³n primero");
    window.location.href = "login.html";
    return;
  }

  // Verificar que los elementos existen
  const contenedor = document.getElementById("citasContainer");
  const btnNuevaReserva = document.getElementById("btnNuevaReserva");
 
  console.log("ðŸ“¦ Contenedor encontrado:", contenedor ? "SÃ­" : "No");
  console.log("ðŸ”˜ BotÃ³n encontrado:", btnNuevaReserva ? "SÃ­" : "No");
 
  if (!contenedor) {
    console.error("âŒ No se encontrÃ³ el elemento citasContainer");
    alert("Error: No se pudo cargar la pÃ¡gina correctamente");
    return;
  }

  // Cargar citas
  cargarCitas(contenedor);

  // Configurar botÃ³n de nueva reserva
  if (btnNuevaReserva) {
    btnNuevaReserva.addEventListener("click", function() {
      localStorage.removeItem("reserva");
      window.location.href = "seleccionar_fecha.html";
    });
  }
});

// FunciÃ³n para cargar citas del usuario
async function cargarCitas(contenedor) {
  console.log("ðŸ”„ === INICIANDO CARGA DE CITAS ===");
  
  try {
    console.log("ðŸ“ URL:", `${backendURL}?action=mis_citas`);
   
    // â­ USAR fetchConAuth
    console.log("ðŸ“¤ Llamando a fetchConAuth...");
    const res = await fetchConAuth(`${backendURL}?action=mis_citas`, {
      method: "GET"
    });

    console.log("ðŸ“¥ Respuesta de fetchConAuth:", res);

    // Si fetchConAuth devuelve null, ya se encargÃ³ de redirigir
    if (!res) {
      console.error("âŒ fetchConAuth devolviÃ³ null - usuario redirigido");
      return;
    }

    console.log("ðŸ“¡ Status:", res.status);
    console.log("âœ… OK:", res.ok);

    // Parsear JSON
    const data = await res.json();
    console.log("ðŸ“¦ Datos JSON completos:", JSON.stringify(data, null, 2));

    // Verificar si la respuesta es OK
    if (!res.ok) {
      console.error("âŒ Response no OK:", data);
      throw new Error(data.error || `Error HTTP ${res.status}`);
    }

    // Verificar success en la respuesta
    if (data.success === false) {
      console.error("âŒ Success = false:", data.error);
      throw new Error(data.error || "El servidor devolviÃ³ success: false");
    }

    // Verificar si hay citas
    if (!data.citas) {
      console.warn("âš ï¸ No hay propiedad 'citas' en la respuesta");
      throw new Error("Respuesta invÃ¡lida del servidor");
    }

    if (data.citas.length === 0) {
      console.log("â„¹ï¸ Array de citas vacÃ­o");
      contenedor.innerHTML = `
        <div style="
          text-align: center; 
          padding: 40px 20px;
          background: rgba(255, 255, 255, 0.08);
          border-radius: 14px;
          margin: 20px 0;
        ">
          <div style="font-size: 4rem; margin-bottom: 16px; opacity: 0.9;">
         
          </div>
          <h2 style="
            font-size: 1.3rem; 
            margin-bottom: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
          ">
            No tienes citas reservadas
          </h2>
          <p style="
            opacity: 0.8; 
            font-size: 0.95rem;
            line-height: 1.6;
            max-width: 280px;
            margin: 0 auto;
          ">
            
          </p>
        </div>
      `;
      return;
    }

    // ðŸ”„ FILTRAR SOLO CITAS NO CANCELADAS
    const citasActivas = data.citas.filter(cita => cita.estado !== 'cancelada');
    
    console.log("ðŸ“Š Total citas:", data.citas.length);
    console.log("ðŸ“Š Citas activas:", citasActivas.length);

    if (citasActivas.length === 0) {
      console.log("â„¹ï¸ No hay citas activas");
      contenedor.innerHTML = `
        <div style="
          text-align: center; 
          padding: 40px 20px;
          background: rgba(255, 255, 255, 0.08);
          border-radius: 14px;
          margin: 20px 0;
        ">
          <div style="font-size: 4rem; margin-bottom: 16px; opacity: 0.9;">
            ðŸ“…
          </div>
          <h2 style="
            font-size: 1.3rem; 
            margin-bottom: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
          ">
            No tienes citas activas
          </h2>
          <p style="
            opacity: 0.8; 
            font-size: 0.95rem;
            line-height: 1.6;
            max-width: 280px;
            margin: 0 auto;
          ">
            Todas tus citas han sido canceladas
          </p>
        </div>
      `;
      return;
    }

    // Limpiar contenedor
    contenedor.innerHTML = "";
   
    // Crear tarjetas
    citasActivas.forEach(function(cita, index) {
      console.log(`âœ… Cita ${index + 1}:`, cita);
     
      const div = document.createElement("div");
      div.className = "cita-card";
     
      // Formatear fecha
      const fechaFormateada = new Date(cita.fecha + 'T00:00:00').toLocaleDateString('es-ES', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      // Estado
      let estadoHTML = "";
      if (cita.estado === "pendiente") {
        estadoHTML = '<span class="estado-badge pendiente">â³ Cita Reservada</span>';
      } else if (cita.estado === "realizada") {
        estadoHTML = '<span class="estado-badge realizada">âœ“ Realizada</span>';
      } else {
        estadoHTML = `<span class="estado-badge">${cita.estado}</span>`;
      }

      div.innerHTML = `
        <div class="cita-info">
          <p><strong>ðŸ“… Fecha:</strong> ${fechaFormateada}</p>
          <p><strong>ðŸ• Hora:</strong> ${cita.hora.slice(0,5)}</p>
          <p><strong>ðŸ’ˆ Servicio:</strong> ${cita.tipo_servicio || 'Corte de pelo'}</p>
          <div style="margin-top: 12px;">
            ${estadoHTML}
          </div>
        </div>
        ${cita.estado === "pendiente" 
          ? `<button onclick="cancelarCita(${cita.id})" class="btn-cancelar">âŒ Cancelar cita</button>`
          : ""
        }
      `;
     
      contenedor.appendChild(div);
    });

    console.log("âœ… === CITAS CARGADAS EXITOSAMENTE ===");

  } catch (error) {
    console.error("âŒ === ERROR EN CARGAR CITAS ===");
    console.error("Tipo:", error.name);
    console.error("Mensaje:", error.message);
    console.error("Stack:", error.stack);
   
    contenedor.innerHTML = `
      <div style="
        text-align: center; 
        padding: 30px 20px; 
        background: rgba(244, 67, 54, 0.15);
        border-radius: 14px;
        border: 1px solid rgba(244, 67, 54, 0.3);
      ">
        <p style="font-size: 2.5rem; margin-bottom: 12px;">âš ï¸</p>
        <p style="font-weight: 600; margin-bottom: 8px;">Error al cargar las citas</p>
        <p style="font-size: 0.85rem; opacity: 0.7; margin-bottom: 16px;">
          ${error.message}
        </p>
        <button onclick="location.reload()" style="
          padding: 10px 20px;
          background: var(--accent, #c44bd6);
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 600;
        ">
          ðŸ”„ Reintentar
        </button>
      </div>
    `;
  }
}

// FunciÃ³n para cancelar cita
window.cancelarCita = async function(citaId) {
  console.log("ðŸ—‘ï¸ === INICIANDO CANCELACIÃ“N ===");
  console.log("Cita ID:", citaId);
 
  const contenedor = document.getElementById("citasContainer");

  if (!confirm("Â¿EstÃ¡s seguro de que quieres cancelar esta cita?")) {
    console.log("âŒ CancelaciÃ³n abortada");
    return;
  }

  try {
    console.log("ðŸ“¤ Enviando solicitud...");
   
    const res = await fetchConAuth(`${backendURL}?action=cancelar_cita`, {
      method: "POST",
      body: JSON.stringify({ cita_id: citaId })
    });

    if (!res) {
      console.error("âŒ fetchConAuth devolviÃ³ null");
      return;
    }

    console.log("ðŸ“¡ Status:", res.status);
   
    const data = await res.json();
    console.log("ðŸ“¦ Respuesta:", data);

    if (res.ok && data.success) {
      alert("âœ… Cita cancelada correctamente");
      console.log("ðŸ”„ Recargando citas...");
      await cargarCitas(contenedor);
    } else {
      const errorMsg = data.error || data.message || "Error desconocido";
      console.error("âŒ Error:", errorMsg);
      alert("No se pudo cancelar: " + errorMsg);
    }
  } catch (error) {
    console.error("âŒ Error:", error);
    alert("Error de conexiÃ³n");
  }
}

console.log("âœ… mis_citas.js cargado");

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\panel_barbero.js
============================
// ===============================================
// PANEL DEL BARBERO - LÃ“GICA
// ===============================================

// âœ… VERIFICAR QUE backendURL EXISTE
if (typeof backendURL === 'undefined') {
  console.error('âŒ CRÃTICO: backendURL no estÃ¡ definido');
  alert('Error de configuraciÃ³n. Por favor, recarga la pÃ¡gina.');
  throw new Error('backendURL is not defined');
}

console.log('âœ… backendURL disponible:', backendURL);

let fechaActual = new Date();

// ===============================================
// INICIALIZACIÃ“N
// ===============================================
document.addEventListener('DOMContentLoaded', function() {
  console.log('ðŸ”§ Inicializando panel del barbero...');
  
  // Verificar que el usuario es admin
  verificarRolAdmin();
  
  // Configurar fecha actual
  actualizarInputFecha();
  
  // Cargar citas del dÃ­a actual
  cargarCitas();
  
  // Configurar eventos
  configurarEventos();
});

// ===============================================
// VERIFICAR ROL DE ADMIN (SIN ASYNC)
// ===============================================
function verificarRolAdmin() {
  const token = localStorage.getItem('jwtToken');
  
  if (!token) {
    alert('ðŸ”’ Debes iniciar sesiÃ³n como administrador');
    window.location.href = 'login.html';
    return;
  }
  
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    
    console.log('ðŸ” Verificando rol:', payload.data.rol);
    
    // â­ SOLO PERMITIR admin
    if (!payload.data.rol || payload.data.rol !== 'admin') {
      alert('â›” Acceso denegado. Solo administradores pueden acceder a este panel.');
      window.location.href = 'home.html';
      return;
    }
    
    console.log('âœ… Usuario verificado como admin');
    
  } catch (error) {
    console.error('âŒ Error verificando rol:', error);
    alert('Error de autenticaciÃ³n');
    window.location.href = 'login.html';
  }
}

// ===============================================
// CONFIGURAR EVENTOS
// ===============================================
function configurarEventos() {
  // BotÃ³n HOY
  document.getElementById('btnHoy').addEventListener('click', () => {
    fechaActual = new Date();
    actualizarInputFecha();
    cargarCitas();
  });
  
  // BotÃ³n dÃ­a anterior
  document.getElementById('btnDiaAnterior').addEventListener('click', () => {
    fechaActual.setDate(fechaActual.getDate() - 1);
    actualizarInputFecha();
    cargarCitas();
  });
  
  // BotÃ³n dÃ­a siguiente
  document.getElementById('btnDiaSiguiente').addEventListener('click', () => {
    fechaActual.setDate(fechaActual.getDate() + 1);
    actualizarInputFecha();
    cargarCitas();
  });
  
  // Input de fecha manual
  document.getElementById('inputFecha').addEventListener('change', (e) => {
    fechaActual = new Date(e.target.value + 'T00:00:00');
    cargarCitas();
  });
  
  // BotÃ³n resumen semanal
  document.getElementById('btnResumenSemanal').addEventListener('click', () => {
    mostrarResumenSemanal();
  });
  
  // Cerrar sesiÃ³n
  document.getElementById('btnCerrarSesion').addEventListener('click', () => {
    if (confirm('Â¿Cerrar sesiÃ³n?')) {
      localStorage.removeItem('jwtToken');
      localStorage.removeItem('usuarioNombre');
      window.location.href = 'login.html';
    }
  });
  
  // Cerrar modal
  document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('modalResumen').style.display = 'none';
  });
  
  // Cerrar modal al hacer clic fuera
  window.addEventListener('click', (e) => {
    const modal = document.getElementById('modalResumen');
    if (e.target === modal) {
      modal.style.display = 'none';
    }
  });
}

// ===============================================
// ACTUALIZAR INPUT DE FECHA
// ===============================================
function actualizarInputFecha() {
  const inputFecha = document.getElementById('inputFecha');
  const fechaStr = fechaActual.toISOString().split('T')[0];
  inputFecha.value = fechaStr;
}

// ===============================================
// CARGAR CITAS DEL DÃA
// ===============================================
async function cargarCitas() {
  const listaCitas = document.getElementById('listaCitas');
  const estadisticas = document.getElementById('estadisticas');
  
  listaCitas.innerHTML = '<p class="loading">â³ Cargando citas...</p>';
  estadisticas.innerHTML = '';
  
  const fechaStr = fechaActual.toISOString().split('T')[0];
  
  try {
    const res = await fetchConAuth(`${backendURL}?action=citas_por_fecha&fecha=${fechaStr}`, {
      method: 'GET'
    });
    
    if (!res) return;
    
    const data = await res.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Error al cargar citas');
    }
    
    // Mostrar estadÃ­sticas
    mostrarEstadisticas(data.estadisticas);
    
    // Mostrar citas
    if (data.citas.length === 0) {
      mostrarMensajeVacio(fechaStr);
    } else {
      mostrarCitas(data.citas);
    }
    
  } catch (error) {
    console.error('âŒ Error:', error);
    listaCitas.innerHTML = `
      <div class="mensaje-vacio">
        <p style="color: #f44336;">âŒ Error al cargar citas: ${error.message}</p>
      </div>
    `;
  }
}

// ===============================================
// MOSTRAR ESTADÃSTICAS
// ===============================================
function mostrarEstadisticas(stats) {
  const estadisticas = document.getElementById('estadisticas');
  
  estadisticas.innerHTML = `
    <div class="stat-card total">
      <span class="stat-numero">${stats.total}</span>
      <span class="stat-label">Total</span>
    </div>
    <div class="stat-card pendientes">
      <span class="stat-numero">${stats.pendientes}</span>
      <span class="stat-label">Pendientes</span>
    </div>
    <div class="stat-card realizadas">
      <span class="stat-numero">${stats.realizadas}</span>
      <span class="stat-label">Realizadas</span>
    </div>
    <div class="stat-card canceladas">
      <span class="stat-numero">${stats.canceladas}</span>
      <span class="stat-label">Canceladas</span>
    </div>
  `;
}

// ===============================================
// MOSTRAR CITAS
// ===============================================
function mostrarCitas(citas) {
  const listaCitas = document.getElementById('listaCitas');
  listaCitas.innerHTML = '';
  
  citas.forEach(cita => {
    const div = document.createElement('div');
    div.className = `cita-barbero ${cita.estado}`;
    
    const estadoBadge = obtenerBadgeEstado(cita.estado);
    const botonRealizar = cita.estado === 'pendiente' 
      ? `<button class="btn-accion btn-realizar" onclick="marcarComoRealizada(${cita.id})">
           âœ… Marcar como realizada
         </button>`
      : `<button class="btn-accion btn-realizar" disabled>
           ${estadoBadge}
         </button>`;
    
    div.innerHTML = `
      <div class="cita-hora">ðŸ• ${formatearHora(cita.hora)}</div>
      
      <div class="cita-info-grid">
        <div class="cita-info-row">
          <strong>ðŸ‘¤ Cliente:</strong>
          <span>${cita.nombre_cliente || 'Sin nombre'}</span>
        </div>
        
        <div class="cita-info-row">
          <strong>ðŸ“ž TelÃ©fono:</strong>
          <span>
            <a href="tel:${cita.telefono_cliente}" class="telefono-link">
              ${cita.telefono_cliente || 'Sin telÃ©fono'}
            </a>
          </span>
        </div>
        
        <div class="cita-info-row">
          <strong>âœ‚ï¸ Servicio:</strong>
          <span>${cita.tipo_servicio || 'No especificado'}</span>
        </div>
        
        ${cita.email ? `
          <div class="cita-info-row">
            <strong>ðŸ“§ Email:</strong>
            <span>${cita.email}</span>
          </div>
        ` : ''}
        
        ${cita.notas ? `
          <div class="cita-info-row">
            <strong>ðŸ“ Notas:</strong>
            <span>${cita.notas}</span>
          </div>
        ` : ''}
      </div>
      
      <div class="cita-acciones">
        ${botonRealizar}
      </div>
    `;
    
    listaCitas.appendChild(div);
  });
}

// ===============================================
// MOSTRAR MENSAJE VACÃO
// ===============================================
function mostrarMensajeVacio(fecha) {
  const listaCitas = document.getElementById('listaCitas');
  const fechaFormateada = formatearFecha(fecha);
  
  listaCitas.innerHTML = `
    <div class="mensaje-vacio">
      <div class="mensaje-vacio-icono">ðŸ“…</div>
      <h3>No hay citas programadas</h3>
      <p>No tienes citas para el ${fechaFormateada}</p>
    </div>
  `;
}

// ===============================================
// MARCAR CITA COMO REALIZADA
// ===============================================
async function marcarComoRealizada(citaId) {
  if (!confirm('Â¿Marcar esta cita como realizada?')) {
    return;
  }
  
  try {
    const res = await fetchConAuth(`${backendURL}?action=marcar_realizada`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ cita_id: citaId })
    });
    
    if (!res) return;
    
    const data = await res.json();
    
    if (data.success) {
      alert('âœ… Cita marcada como realizada');
      cargarCitas();
    } else {
      throw new Error(data.error || 'Error al actualizar');
    }
    
  } catch (error) {
    console.error('âŒ Error:', error);
    alert('âŒ Error al marcar cita: ' + error.message);
  }
}

// ===============================================
// MOSTRAR RESUMEN SEMANAL
// ===============================================
async function mostrarResumenSemanal() {
  const modal = document.getElementById('modalResumen');
  const contenido = document.getElementById('contenidoResumen');
  
  contenido.innerHTML = '<p class="loading">â³ Cargando resumen...</p>';
  modal.style.display = 'flex';
  
  try {
    const res = await fetchConAuth(`${backendURL}?action=resumen_semanal`, {
      method: 'GET'
    });
    
    if (!res) return;
    
    const data = await res.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Error al cargar resumen');
    }
    
    if (data.resumen.length === 0) {
      contenido.innerHTML = `
        <div class="mensaje-vacio">
          <p>ðŸ“­ No hay citas esta semana</p>
        </div>
      `;
      return;
    }
    
    let html = `
      <p style="margin-bottom: 20px; opacity: 0.8;">
        ðŸ“… Del ${formatearFecha(data.rango.inicio)} al ${formatearFecha(data.rango.fin)}
      </p>
    `;
    
    data.resumen.forEach(dia => {
      const diaSemana = obtenerNombreDia(dia.dia);
      html += `
        <div class="resumen-dia">
          <h4>${diaSemana} - ${formatearFecha(dia.dia)}</h4>
          <div class="resumen-stats">
            <span>ðŸ“Š Total: <strong>${dia.total_citas}</strong></span>
            <span>â³ Pendientes: <strong>${dia.pendientes}</strong></span>
            <span>âœ… Realizadas: <strong>${dia.realizadas}</strong></span>
          </div>
        </div>
      `;
    });
    
    contenido.innerHTML = html;
    
  } catch (error) {
    console.error('Error:', error);
    contenido.innerHTML = `
      <div class="mensaje-vacio">
        <p style="color: #f44336;">Error: ${error.message}</p>
      </div>
    `;
  }
}

// ===============================================
// FUNCIONES AUXILIARES
// ===============================================

function obtenerBadgeEstado(estado) {
  const badges = {
    'pendiente': 'â³ Pendiente',
    'confirmada': 'âœ”ï¸ Confirmada',
    'realizada': 'âœ… Realizada',
    'cancelada': 'âŒ Cancelada'
  };
  return badges[estado] || estado;
}

function formatearHora(hora) {
  return hora.substring(0, 5);
}

function formatearFecha(fecha) {
  const d = new Date(fecha + 'T00:00:00');
  const opciones = { day: 'numeric', month: 'long', year: 'numeric' };
  return d.toLocaleDateString('es-ES', opciones);
}

function obtenerNombreDia(fecha) {
  const d = new Date(fecha + 'T00:00:00');
  const dias = ['Domingo', 'Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'];
  return dias[d.getDay()];
}

// ===============================================
// FUNCIÃ“N FETCH CON AUTENTICACIÃ“N
// ===============================================
async function fetchConAuth(url, options = {}) {
  const token = localStorage.getItem('jwtToken');
  
  if (!token) {
    alert('SesiÃ³n expirada. Por favor, inicia sesiÃ³n nuevamente.');
    window.location.href = 'login.html';
    return null;
  }
  
  options.headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`
  };
  
  try {
    const response = await fetch(url, options);
    
    if (response.status === 401 || response.status === 403) {
      alert('SesiÃ³n expirada o acceso denegado.');
      localStorage.removeItem('jwtToken');
      window.location.href = 'login.html';
      return null;
    }
    
    return response;
    
  } catch (error) {
    console.error('Error en la peticiÃ³n:', error);
    throw error;
  }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\perfil.js
============================


let datosUsuario = null;

// Verificar sesiÃ³n al cargar
window.addEventListener('DOMContentLoaded', function() {
  console.log("Cargando perfil...");
  
  const token = localStorage.getItem("jwtToken");
  
  if (!token) {
    alert("Debes iniciar sesiÃ³n primero");
    window.location.href = "login.html";
    return;
  }
  
  cargarPerfil(token);
  configurarEventos();
});

// Cargar datos del perfil
async function cargarPerfil(token) {
  const perfilView = document.getElementById("perfilView");
  const mensajeDiv = document.getElementById("mensaje");
  
  try {
    console.log("Solicitando datos del perfil...");
    
    const res = await fetchConAuth(`${backendURL}?action=obtener_perfil`, {
      method: "GET",
      headers: {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json"
      }
    });
    
    console.log("Respuesta recibida:", res.status);
    
    const data = await res.json();
    console.log("Datos:", data);
    
    if (!res.ok) {
      throw new Error(data.error || "Error al cargar perfil");
    }
    
    if (data.success && data.usuario) {
      datosUsuario = data.usuario;
      mostrarPerfil(data.usuario);
      perfilView.style.display = "block";
    } else {
      throw new Error("No se recibieron datos del usuario");
    }
    
  } catch (error) {
    console.error("Error:", error);
    mensajeDiv.textContent = "" + error.message;
    mensajeDiv.style.color = "red";
    
    // Si el token expirÃ³, redirigir
    if (error.message.includes("Token") || error.message.includes("sesiÃ³n")) {
      setTimeout(() => {
        localStorage.removeItem("jwtToken");
        window.location.href = "login.html";
      }, 2000);
    }
  }
}

// Mostrar datos del perfil
function mostrarPerfil(usuario) {
  console.log("Mostrando perfil:", usuario);
  
  // Nombre completo
  const nombreCompleto = usuario.apellidos 
    ? `${usuario.nombre} ${usuario.apellidos}` 
    : usuario.nombre;
  document.getElementById("viewNombre").textContent = nombreCompleto;
  
  // Email
  document.getElementById("viewEmail").textContent = usuario.email;
  
  // TelÃ©fono
  document.getElementById("viewTelefono").textContent = usuario.telefono || "No especificado";
  
  // Fecha de registro
  if (usuario.fecha_registro) {
    const fecha = new Date(usuario.fecha_registro);
    const opciones = { year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById("viewFechaRegistro").textContent = fecha.toLocaleDateString('es-ES', opciones);
  }
  
  // Total de citas
  document.getElementById("viewTotalCitas").textContent = usuario.total_citas || 0;
}

// Configurar eventos
function configurarEventos() {
  // BotÃ³n editar perfil
  document.getElementById("btnEditarPerfil").addEventListener("click", function() {
    mostrarFormularioEdicion();
  });
  
  // BotÃ³n cancelar ediciÃ³n
  document.getElementById("btnCancelarEdicion").addEventListener("click", function() {
    ocultarFormularioEdicion();
  });
  
  // Formulario de ediciÃ³n
  document.getElementById("perfilForm").addEventListener("submit", async function(e) {
    e.preventDefault();
    await guardarCambios();
  });
  
  // BotÃ³n cerrar sesiÃ³n
  document.getElementById("btnCerrarSesion").addEventListener("click", function() {
    cerrarSesion();
  });
}

// Mostrar formulario de ediciÃ³n
function mostrarFormularioEdicion() {
  console.log("Activando modo ediciÃ³n");
  
  // Rellenar campos con datos actuales
  document.getElementById("editNombre").value = datosUsuario.nombre;
  document.getElementById("editApellidos").value = datosUsuario.apellidos || "";
  document.getElementById("editTelefono").value = datosUsuario.telefono;
  
  // Cambiar vistas
  document.getElementById("perfilView").style.display = "none";
  document.getElementById("perfilEdit").style.display = "block";
  
  // Limpiar mensaje
  document.getElementById("mensaje").textContent = "";
}

// Ocultar formulario de ediciÃ³n
function ocultarFormularioEdicion() {
  console.log("Volviendo a modo visualizaciÃ³n");
  
  document.getElementById("perfilView").style.display = "block";
  document.getElementById("perfilEdit").style.display = "none";
  
  // Limpiar mensaje
  document.getElementById("mensaje").textContent = "";
}

// Guardar cambios del perfil
async function guardarCambios() {
  const token = localStorage.getItem("jwtToken");
  const mensajeDiv = document.getElementById("mensaje");
  const btnSubmit = document.querySelector("#perfilForm button[type='submit']");
  
  if (!token) {
    alert("SesiÃ³n expirada. Por favor, inicia sesiÃ³n nuevamente.");
    window.location.href = "login.html";
    return;
  }
  
  // Obtener valores del formulario
  const nombre = document.getElementById("editNombre").value.trim();
  const apellidos = document.getElementById("editApellidos").value.trim();
  const telefono = document.getElementById("editTelefono").value.trim();
  
  if (!nombre || !telefono) {
    mensajeDiv.textContent = "Completa los campos obligatorios";
    mensajeDiv.style.color = "#ff6b6b";
    return;
  }
  
  // Validar telÃ©fono (9 dÃ­gitos)
  if (!/^[0-9]{9}$/.test(telefono)) {
    mensajeDiv.textContent = "El telÃ©fono debe tener 9 dÃ­gitos";
    mensajeDiv.style.color = "#ff6b6b";
    return;
  }
  
  try {
    btnSubmit.disabled = true;
    btnSubmit.textContent = "Guardando...";
    
    console.log("ðŸ“¤ Enviando actualizaciÃ³n...");
    
    const res = await fetchConAuth(`${backendURL}?action=actualizar_perfil`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({
        nombre: nombre,
        apellidos: apellidos,
        telefono: telefono
      })
    });
    
    const data = await res.json();
    console.log("ðŸ“¥ Respuesta:", data);
    
    if (res.ok && data.success) {
      mensajeDiv.textContent = "Perfil actualizado correctamente";
      mensajeDiv.style.color = "#4caf50";
      
      // Actualizar localStorage
      localStorage.setItem("usuarioNombre", nombre);
      
      // Recargar datos
      setTimeout(async () => {
        await cargarPerfil(token);
        ocultarFormularioEdicion();
        mensajeDiv.textContent = "";
      }, 1500);
      
    } else {
      throw new Error(data.error || "Error al actualizar perfil");
    }
    
  } catch (error) {
    console.error("Error:", error);
    mensajeDiv.textContent = "" + error.message;
    mensajeDiv.style.color = "#ff6b6b";
  } finally {
    btnSubmit.disabled = false;
    btnSubmit.textContent = "Guardar";
  }
}

// Cerrar sesiÃ³n
function cerrarSesion() {
  if (confirm("Â¿EstÃ¡s seguro de que quieres cerrar sesiÃ³n?")) {
    console.log("Cerrando sesiÃ³n...");
    
    // Limpiar localStorage
    localStorage.removeItem("jwtToken");
    localStorage.removeItem("usuarioNombre");
    localStorage.removeItem("reserva");
    
    // Redirigir a login
    window.location.href = "login.html";
  }
}

console.log("perfil.js cargado correctamente");

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\register.js
============================


const registerForm = document.getElementById("registerForm");
const mensajeDiv = document.getElementById("mensaje");


registerForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const nombre = document.getElementById("regNombre").value;
      const apellidos = document.getElementById("regApellidos").value;
      const telefono = document.getElementById("regTelefono").value;
      const email = document.getElementById("regEmail").value;
      const password = document.getElementById("regPassword").value;


      // Preparar objeto para enviar al backend
      const datosRegistro = {
        nombre,
        apellidos,
        telefono,
        email,
        password  
      };

      try {
        const res = await fetch(`${backendURL}?action=register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(datosRegistro)
        });

        const data = await res.json();

        if (res.ok) {
          mensajeDiv.textContent = "Registro completado con Ã©xito";
          mensajeDiv.style.color = "green";

          setTimeout(() => {
            window.location.href = "login.html";
          }, 1000);
        } else {
          mensajeDiv.textContent = "" + (data.error || "Error al registrarse");
          mensajeDiv.style.color = "red";
        }
      } catch (err) {
        mensajeDiv.textContent = " Error de conexiÃ³n: " + err;
        mensajeDiv.style.color = "red";
      }
    });

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\js\reservas.js
============================


// =======================================
// VARIABLES COMUNES
// =======================================

let reserva = {
  fecha: "",
  hora: "",
  servicio_id: null,
  servicio_nombre: "",
  cliente_id: null
};

// 0ï¸. Obtener cliente_id del usuario logueado (JWT)
function obtenerClienteID() {
  const token = localStorage.getItem("jwtToken");
  if (!token) {
    console.error(" No hay token JWT");
    return null;
  }
 
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    console.log(" Cliente ID obtenido:", payload.data.cliente_id);
    return payload.data.cliente_id;
  } catch (error) {
    console.error(" Error al decodificar JWT:", error);
    return null;
  }
}

// 1ï¸. Seleccionar fecha
function guardarFecha() {
  const fechaInput = document.getElementById("fecha");
  const fechaForm = document.getElementById("fechaForm");
  if (!fechaInput || !fechaForm) return;

  const hoy = new Date().toISOString().split('T')[0];
  fechaInput.setAttribute('min', hoy);

  fechaForm.addEventListener("submit", (e) => {
    e.preventDefault();

    if (!fechaInput.value) {
      alert(" Selecciona una fecha");
      return;
    }

    const fechaSeleccionada = new Date(fechaInput.value);
    const hoyDate = new Date();
    hoyDate.setHours(0, 0, 0, 0);

    if (fechaSeleccionada < hoyDate) {
      alert(" No puedes seleccionar una fecha pasada");
      return;
    }

    reserva.fecha = fechaInput.value;
    reserva.cliente_id = obtenerClienteID();

    if (!reserva.cliente_id) {
      alert(" Debes iniciar sesiÃ³n primero");
      window.location.href = "login.html";
      return;
    }

    localStorage.setItem("reserva", JSON.stringify(reserva));
    console.log(" Fecha guardada:", reserva);
    window.location.href = "seleccionar_hora.html";
  });
}

// 2ï¸. Seleccionar hora (CON CARGA DE HORAS OCUPADAS - MEJORADO)
async function cargarHorasDisponibles() {
  const horasGrid = document.getElementById("horasGrid");
  const horaForm = document.getElementById("horaForm");
  const btnSiguiente = document.getElementById("btnSiguienteHora");

  if (!horasGrid || !horaForm || !btnSiguiente) {
    console.error(" No se encontraron elementos necesarios");
    return;
  }

  const horasDisponibles = [
    "09:30", "10:00", "10:30", "11:00", "11:30", "12:00",
    "12:30", "13:00", "13:30",
    "16:00", "16:30", "17:00", "17:30", "18:00", "18:30",
    "19:00", "19:30", "20:00", "20:30"
  ];

  btnSiguiente.disabled = true;
  horasGrid.innerHTML = "<p style='text-align: center; opacity: 0.7; grid-column: 1 / -1;'>Cargando horas disponibles...</p>";

  //  CARGAR HORAS OCUPADAS DESDE EL BACKEND
  reserva = JSON.parse(localStorage.getItem("reserva")) || {};
  let horasOcupadas = [];

  if (!reserva.fecha) {
    console.error(" No hay fecha en localStorage");
    horasGrid.innerHTML = "<p style='color: red; grid-column: 1 / -1;'>Error: No se ha seleccionado una fecha</p>";
    return;
  }

  try {
    const url = `${backendURL}?action=horas_ocupadas&fecha=${encodeURIComponent(reserva.fecha)}`;
    console.log(" Consultando horas ocupadas...");
    console.log(" URL:", url);
    console.log(" Fecha:", reserva.fecha);

    const res = await fetchConAuth(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      mode: 'cors',
      cache: 'no-cache'
    });

    console.log(" Status de respuesta:", res.status);
    
    const responseText = await res.text();
    console.log(" Respuesta RAW:", responseText);

    let data;
    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
      console.error(" Error parseando JSON:", parseError);
      data = { success: false, horas_ocupadas: [] };
    }

    console.log(" Datos parseados:", data);

    if (data.success && Array.isArray(data.horas_ocupadas)) {
      horasOcupadas = data.horas_ocupadas;
      console.log(" Horas ocupadas recibidas:", horasOcupadas);
      console.log(" Total horas ocupadas:", horasOcupadas.length);
    } else {
      console.warn(" No se pudieron cargar las horas ocupadas, continuando sin ellas");
      horasOcupadas = [];
    }
  } catch (error) {
    console.error(" Error al cargar horas ocupadas:", error);
    console.error("   Mensaje:", error.message);
    horasOcupadas = [];
  }

  // Limpiar y crear grid de horas
  horasGrid.innerHTML = "";

  horasDisponibles.forEach((hora, index) => {
    const div = document.createElement("div");
    div.className = "hora-btn";
    div.textContent = hora;

    //  VERIFICAR SI LA HORA ESTÃ OCUPADA (con normalizaciÃ³n de formato)
    const estaOcupada = horasOcupadas.some(horaOcupada => {
      // Normalizar las horas eliminando segundos si existen
      // "18:00:00" -> "18:00"
      // "18:00" -> "18:00"
      const horaLimpia = String(horaOcupada).trim().substring(0, 5);
      const horaActual = String(hora).trim();
      return horaLimpia === horaActual;
    });

    console.log(` Hora ${hora}: ${estaOcupada ? ' OCUPADA' : ' disponible'}`);

    if (estaOcupada) {
      div.classList.add("ocupada");
      div.style.cursor = "not-allowed";
      div.style.pointerEvents = "none"; //  BLOQUEAR COMPLETAMENTE EL CLICK
      div.title = " Hora no disponible";
      console.log(`   â†’ Aplicada clase 'ocupada' a ${hora}`);
    } else {
      // Solo permitir click en horas disponibles
      div.addEventListener("click", () => {
        console.log(` Click en hora disponible: ${hora}`);
        
        // Remover selecciÃ³n de otras horas disponibles
        document.querySelectorAll(".hora-btn:not(.ocupada)")
          .forEach(h => h.classList.remove("selected"));

        div.classList.add("selected");

        reserva = JSON.parse(localStorage.getItem("reserva")) || {};
        reserva.hora = hora;
        localStorage.setItem("reserva", JSON.stringify(reserva));

        console.log(" Hora guardada en localStorage:", hora);

        btnSiguiente.disabled = false;
      });
    }

    horasGrid.appendChild(div);
  });

  console.log(" Grid de horas renderizado completamente");

  horaForm.addEventListener("submit", (e) => {
    e.preventDefault();

    if (!reserva.hora) {
      alert(" Selecciona una hora");
      return;
    }

    window.location.href = "seleccionar_servicio.html";
  });
}

// 3ï¸. Seleccionar servicio
function guardarServicio() {
  const servicioSelect = document.getElementById("servicio");
  const servicioForm = document.getElementById("servicioForm");
  if (!servicioSelect || !servicioForm) return;

  servicioForm.addEventListener("submit", (e) => {
    e.preventDefault();

    if (!servicioSelect.value) {
      alert(" Selecciona un servicio");
      return;
    }

    reserva = JSON.parse(localStorage.getItem("reserva")) || {};

    reserva.servicio_id = parseInt(servicioSelect.value);
    reserva.servicio_nombre = servicioSelect.options[servicioSelect.selectedIndex].text;

    if (!reserva.cliente_id) {
      reserva.cliente_id = obtenerClienteID();
    }

    if (!reserva.cliente_id) {
      alert(" Debes iniciar sesiÃ³n primero");
      window.location.href = "login.html";
      return;
    }

    localStorage.setItem("reserva", JSON.stringify(reserva));
    console.log(" Servicio guardado:", reserva);
    window.location.href = "resumen_cita.html";
  });
}

// 4ï¸ Mostrar resumen y confirmar cita
function mostrarResumen() {
  const output = document.getElementById("output");
  const btnConfirmar = document.getElementById("btnConfirmarCita");
  if (!output || !btnConfirmar) return;

  reserva = JSON.parse(localStorage.getItem("reserva")) || {};
  if (!reserva.cliente_id) {
    reserva.cliente_id = obtenerClienteID();
  }

  if (!reserva.fecha || !reserva.hora || !reserva.servicio_id || !reserva.cliente_id) {
    output.innerHTML = `
      <p style="color: red;"> Faltan datos de la reserva.</p>
      <p>Por favor, completa el proceso desde el inicio.</p>
    `;
    btnConfirmar.disabled = true;
    return;
  }

  output.innerHTML = `
    <h2>ConfirmaciÃ³n de Cita</h2>
    <div>
      <p><strong> Fecha:</strong> ${formatearFecha(reserva.fecha)}</p>
      <p><strong> Hora:</strong> ${reserva.hora}</p>
      <p><strong> Servicio:</strong> ${reserva.servicio_nombre || 'Servicio seleccionado'}</p>
    </div>
    <p>Por favor, revisa que todos los datos sean correctos antes de confirmar.</p>
  `;

  console.log("Datos a enviar:", reserva);

  btnConfirmar.addEventListener("click", async () => {
    if (!reserva.fecha || !reserva.hora || !reserva.servicio_id || !reserva.cliente_id) {
      alert(" Datos incompletos. Por favor, reinicia el proceso de reserva.");
      return;
    }

    const datosEnviar = {
      fecha: reserva.fecha,
      hora: reserva.hora,
      servicio_id: reserva.servicio_id,
      cliente_id: reserva.cliente_id
    };

    try {
      const jsonString = JSON.stringify(datosEnviar);
      console.log(" JSON que se enviarÃ¡:", jsonString);
      console.log(" URL destino:", `${backendURL}?action=reservar`);

      btnConfirmar.disabled = true;
      btnConfirmar.textContent = "Procesando...";

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);

      const res = await fetchConAuth(`${backendURL}?action=reservar`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: jsonString,
        signal: controller.signal,
        mode: 'cors',
        cache: 'no-cache'
      });

      clearTimeout(timeoutId);

      console.log(" Respuesta del servidor - Status:", res.status);
      console.log(" Headers:", [...res.headers.entries()]);

      const responseText = await res.text();
      console.log(" Respuesta RAW:", responseText);

      let data;
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.error(" Error parseando JSON:", parseError);
        throw new Error(`Respuesta no vÃ¡lida del servidor: ${responseText.substring(0, 100)}`);
      }

      console.log(" Respuesta del servidor - Data:", data);

      if (res.ok && data.success) {
        alert(" Â¡Cita confirmada correctamente!");
        localStorage.removeItem("reserva");
        window.location.href = "mis_citas.html";
      } else {
        throw new Error(data.error || data.message || 'No se pudo reservar la cita');
      }
    } catch (err) {
      console.error(" Error completo:", err);
     
      let mensajeError = "Error de conexiÃ³n";
     
      if (err.name === 'AbortError') {
        mensajeError = " Tiempo de espera agotado. Verifica tu conexiÃ³n a internet.";
      } else if (err.message.includes('Failed to fetch') || err.message.includes('Load failed')) {
        mensajeError = ` No se puede conectar al servidor.
       
Verifica:
â€¢ Tu mÃ³vil estÃ¡ en la misma red WiFi que el PC
â€¢ La IP del servidor es correcta: ${backendURL}
â€¢ El firewall de Windows permite conexiones entrantes
â€¢ Apache estÃ¡ ejecutÃ¡ndose en el PC`;
      } else {
        mensajeError = ` ${err.message}`;
      }
     
      alert(mensajeError);
      btnConfirmar.disabled = false;
      btnConfirmar.textContent = "Confirmar Cita";
    }
  });
}

// Formatear fecha
function formatearFecha(fecha) {
  const opciones = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  const fechaObj = new Date(fecha + 'T00:00:00');
  return fechaObj.toLocaleDateString('es-ES', opciones);
}

// =======================================
// TEST DE CONECTIVIDAD (Ãºtil para debug)
// =======================================
async function testConexion() {
  try {
    console.log(" Probando conexiÃ³n a:", backendURL);
    const res = await fetch(backendURL, {
      method: 'GET',
      mode: 'cors',
      cache: 'no-cache'
    });
    console.log(" ConexiÃ³n OK, status:", res.status);
    return true;
  } catch (err) {
    console.error(" Error de conexiÃ³n:", err);
    return false;
  }
}

// =======================================
// EJECUTAR SEGÃšN PÃGINA
// =======================================
document.addEventListener("DOMContentLoaded", () => {
  console.log(" reservas.js cargado");
 
  testConexion();
 
  if (document.getElementById("fecha")) guardarFecha();
  if (document.getElementById("horasGrid")) cargarHorasDisponibles();
  if (document.getElementById("servicio")) guardarServicio();
  if (document.getElementById("output")) mostrarResumen();
});

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\email_cancelacion.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #2b0040, #3a005f); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .cita-info { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #f44336; }
        .cita-info p { margin: 10px 0; font-size: 16px; }
        .footer { text-align: center; padding: 20px; color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ’ˆ ProBarberSystem</h1>
        </div>
        <div class="content">
            <h2>Hola {{NOMBRE}},</h2>
            <p>Tu cita ha sido <strong>cancelada</strong>.</p>
            
            <div class="cita-info">
                <p><strong>ðŸ“… Fecha:</strong> {{FECHA}}</p>
                <p><strong>ðŸ• Hora:</strong> {{HORA}}</p>
                <p><strong>ðŸ’ˆ Servicio:</strong> {{SERVICIO}}</p>
            </div>
            
            <p>Puedes reservar una nueva cita cuando lo desees desde la aplicaciÃ³n.</p>
            <p>Â¡Esperamos verte pronto! ðŸ˜Š</p>
        </div>
        <div class="footer">
            <p>Este es un email automÃ¡tico, por favor no respondas a este mensaje.</p>
            <p>&copy; 2025 ProBarberSystem</p>
        </div>
    </div>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\email_confirmacion.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #2b0040, #3a005f); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .cita-info { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #c44bd6; }
        .cita-info p { margin: 10px 0; font-size: 16px; }
        .footer { text-align: center; padding: 20px; color: #666; font-size: 12px; }
        strong { color: #c44bd6; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ’ˆ ProBarberSystem</h1>
        </div>
        <div class="content">
            <h2>Â¡Hola {{NOMBRE}}! </h2>
            <p>Tu cita ha sido <strong>confirmada exitosamente</strong>.</p>
            
            <div class="cita-info">
                <p><strong>ðŸ“… Fecha:</strong> {{FECHA}}</p>
                <p><strong>ðŸ• Hora:</strong> {{HORA}}</p>
                <p><strong>ðŸ’ˆ Servicio:</strong> {{SERVICIO}}</p>
            </div>
            
            <p><strong>Importante:</strong></p>
            <ul>
                <li>Por favor, llega 5 minutos antes de tu hora</li>
                <li>Si necesitas cancelar, hazlo con al menos 2 horas de antelaciÃ³n</li>
                <li>Puedes gestionar tu cita desde la app</li>
            </ul>
            
            <p>Â¡Te esperamos!</p>
        </div>
        <div class="footer">
            <p>Este es un email automÃ¡tico, por favor no respondas a este mensaje.</p>
            <p>&copy; 2025 ProBarberSystem</p>
        </div>
    </div>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\home.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProBarberSystem - Home</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body class="home">

  <div class="home-container">
    
    <div class="buttons-container">
      <a href="login.html" class="btn btn-login">INICIAR SESIÃ“N</a>
      <a href="register.html" class="btn btn-register">CREAR CUENTA</a>
    </div>
  </div>

<script src="../js/config.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\login.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProBarberSystem - Login</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>

  <div class="auth-container">
    <form id="loginForm" class="auth-form">
      <h1>INICIAR SESIÃ“N</h1>
      <!-- Email -->
      <div class="input-group">
        <span>ðŸ“§</span>
        <input type="email" id="email" placeholder="Correo" required>
      </div>
      <!-- Password -->
      <div class="input-group">
        <span>ðŸ”’</span>
        <input type="password" id="password" placeholder="ContraseÃ±a" required>
      </div>
      <button type="submit" id="btnLogin" class="btn-primary">INICIAR SESIÃ“N</button>
    </form>
    <div id="mensaje" class="mensaje"></div>
  </div>

  <script src="../js/config.js"></script>
  <script src="../js/auth.js"></script>
  <script src="../js/login.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\mis_citas.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mis Citas - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>
  <div class="auth-container" style="margin-top: 40px; margin-bottom: 40px;">
    <h1>ðŸ’ˆ MIS CITAS</h1>
   
    <div id="citasContainer">
      <p style="text-align: center; opacity: 0.7;">Cargando tus citas...</p>
    </div>

    <button id="btnNuevaReserva" class="btn-primary" style="margin-top: 20px;">
      Reservar Cita  
    </button> <br>
    
    <!-- BOTÃ“N DE PERFIL AÃ‘ADIDO -->
    <button onclick="window.location.href='perfil.html'" class="btn-secondary" style="margin-top: 12px;">
      Mi perfil
    </button>
  </div>

  <script src="../js/config.js"></script>
  <script src="../js/mis_citas.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\offline.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sin conexiÃ³n - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <div class="auth-container" style="margin-top: 100px; text-align: center;">
    <h1 style="font-size: 4rem; margin-bottom: 20px;">ðŸ“¡</h1>
    <h2>Sin conexiÃ³n a Internet</h2>
    <p style="margin: 20px 0; opacity: 0.8;">
      No se puede conectar con el servidor.
    </p>
    <p style="margin-bottom: 30px; opacity: 0.7;">
      Por favor, verifica tu conexiÃ³n e intÃ©ntalo de nuevo.
    </p>
    <button onclick="location.reload()" class="btn-primary">
      Reintentar
    </button>
    <button onclick="window.location.href='home.html'" class="btn-secondary" style="margin-top: 10px;">
      Volver al inicio
    </button>
  </div>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\panel_barbero.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel del Barbero - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>

  <div class="panel-container">
    
    <!-- Header con fecha y estadÃ­sticas -->
    <div class="panel-header">
      <div class="header-top">
        <h1>ðŸ’ˆ Panel del Barbero</h1>
        <button id="btnCerrarSesion" class="btn-icon" title="Cerrar sesiÃ³n">
          ðŸšª
        </button>
      </div>

      <!-- Selector de fecha -->
      <div class="fecha-selector">
        <button id="btnDiaAnterior" class="btn-nav">â—€</button>
        <div class="fecha-actual">
          <input type="date" id="inputFecha" class="input-fecha">
          <button id="btnHoy" class="btn-hoy">HOY</button>
        </div>
        <button id="btnDiaSiguiente" class="btn-nav">â–¶</button>
      </div>

      <!-- EstadÃ­sticas del dÃ­a -->
      <div id="estadisticas" class="estadisticas">
        <!-- Se llena dinÃ¡micamente -->
      </div>
    </div>

    <!-- Lista de citas -->
    <div id="listaCitas" class="lista-citas">
      <p class="loading">Cargando citas...</p>
    </div>

    <!-- Resumen semanal (opcional) -->
    <div class="panel-footer">
      <button id="btnResumenSemanal" class="btn-secondary">
        ðŸ“Š Ver resumen semanal
      </button>
    </div>

  </div>

  <!-- Modal para resumen semanal -->
  <div id="modalResumen" class="modal" style="display: none;">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>ðŸ“Š Resumen Semanal</h2>
      <div id="contenidoResumen"></div>
    </div>
  </div>

  <script src="../js/config.js"></script>
  <script src="../js/auth.js"></script>
  <script src="../js/panel_barbero.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\perfil.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mi Perfil - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>

  <div class="auth-container" style="margin-top: 40px; margin-bottom: 40px;">
    <h1>MI PERFIL</h1>
    
    <!-- Modo visualizaciÃ³n -->
    <div id="perfilView" style="display: none;">
      <div class="perfil-info">
        <div class="perfil-item">
          <span class="perfil-label">ðŸ“ Nombre completo</span>
          <span class="perfil-value" id="viewNombre">-</span>
        </div>
        
        <div class="perfil-item">
          <span class="perfil-label">ðŸ“§ Correo electrÃ³nico</span>
          <span class="perfil-value" id="viewEmail">-</span>
        </div>
        
        <div class="perfil-item">
          <span class="perfil-label">ðŸ“ž TelÃ©fono</span>
          <span class="perfil-value" id="viewTelefono">-</span>
        </div>
        
        <div class="perfil-item">
          <span class="perfil-label">ðŸ“… Miembro desde</span>
          <span class="perfil-value" id="viewFechaRegistro">-</span>
        </div>
        
        <div class="perfil-item">
          <span class="perfil-label">ðŸ’ˆ Total de citas</span>
          <span class="perfil-value" id="viewTotalCitas">0</span>
        </div>
      </div>

      <button id="btnEditarPerfil" class="btn-primary" style="margin-top: 20px;">
        Editar Perfil
      </button>
    </div>

    <!-- Modo ediciÃ³n -->
    <div id="perfilEdit" style="display: none;">
      <form id="perfilForm" class="auth-form">
        
        <div class="input-group">
          <span>ðŸ‘¤</span>
          <input
            type="text"
            id="editNombre"
            placeholder="Nombre"
            required
          >
        </div>

        <div class="input-group">
          <span>ðŸ§¾</span>
          <input
            type="text"
            id="editApellidos"
            placeholder="Apellidos (opcional)"
          >
        </div>

        <div class="input-group">
          <span>ðŸ“ž</span>
          <input
            type="tel"
            inputmode="numeric"
            pattern="[0-9]{9}"
            id="editTelefono"
            placeholder="TelÃ©fono"
            required
          >
        </div>

        <div style="display: flex; gap: 10px; margin-top: 10px;">
          <button type="submit" class="btn-primary" style="flex: 1;">
            GUARDAR
          </button>
          <button type="button" id="btnCancelarEdicion" class="btn-secondary" style="flex: 1;">
            CANCELAR
          </button>
        </div>
      </form>
    </div>

    <!-- Mensaje de estado -->
    <div id="mensaje" class="mensaje"></div>

    <!-- Botones de acciÃ³n -->
    <div style="margin-top: 30px; display: flex; flex-direction: column; gap: 12px;">
      <button onclick="window.location.href='mis_citas.html'" class="btn-secondary">
        Ver Mis Citas
      </button>
      
      <button onclick="window.location.href='seleccionar_fecha.html'" class="btn-secondary">
        Nueva Reserva
      </button>
      
      <button id="btnCerrarSesion" class="btn-logout">
        Cerrar sesiÃ³n
      </button>
    </div>
  </div>
  <script src="../js/config.js"></script>
  <script src="../js/perfil.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\register.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProBarberSystem - Registro</title>
  <link rel="stylesheet" href="../css/styles.css"> 
</head>
<body>

  <div class="auth-container register-container">
    <h1>NUEVA CUENTA</h1>

    <form id="registerForm" class="auth-form">

      <!-- Nombre obligatorio -->
      <div class="input-group">
        <span>ðŸ‘¤</span>
        <input
          type="text"
          id="regNombre"
          placeholder="Nombre"
          required
        >
      </div>

      <!-- Apellidos opcionales -->
      <div class="input-group">
        <span>ðŸ§¾</span>
        <input
          type="text"
          id="regApellidos"
          placeholder="Apellidos (opcional)"
        >
      </div>

      <!-- TelÃ©fono -->
      <div class="input-group">
        <span>ðŸ“ž</span>
        <input
          type="tel"
          inputmode="numeric"
          pattern="[0-9]{9}"
          id="regTelefono"
          placeholder="TelÃ©fono"
          required
        >
      </div>

      <!-- Correo electrÃ³nico -->
      <div class="input-group">
        <span>ðŸ“§</span>
        <input
          type="email"
          id="regEmail"
          placeholder="Correo electrÃ³nico"
          required
        >
      </div>

      <!-- ContraseÃ±a -->
      <div class="input-group">
        <span>ðŸ”’</span>
        <input
          type="password"
          id="regPassword"
          placeholder="ContraseÃ±a"
          required
        >
      </div>

      <button type="submit" class="btn-primary">
        REGISTRAR
      </button>

    </form>

    <div id="mensaje" class="mensaje"></div>
  </div>

  <script src="../js/config.js"></script>
  <script src="../js/register.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\resumen_cita.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Resumen de Cita - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>
  <!-- Usar resumen-container en lugar de un contenedor genÃ©rico -->
  <div class="auth-container fecha-container">
    <h1>RESUMEN</h1>
    
    <!-- El contenido se genera dinÃ¡micamente desde reservas.js -->
    <div id="output"></div>
    
    <button id="btnConfirmarCita" class="btn-primary">CONFIRMAR CITA</button>
  </div>

<script src="../js/config.js"></script>
<script src="../js/reservas.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\seleccionar_fecha.html
============================
  <!DOCTYPE html>
  <html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seleccionar Fecha - ProBarberSystem</title>
    <link rel="stylesheet" href="../css/styles.css">
    <script src="../js/auth.js"></script>
  </head>
  <body>

    <div class="auth-container fecha-container">

      <h1>SELECCIONAR FECHA</h1>

      <form id="fechaForm" class="auth-form">

        <div class="input-group">
          <span>ðŸ“…</span>
          <input
            type="date"
            id="fecha"
            name="fecha"
            required
          >
        </div>

        <button
          type="submit"
          id="btnSiguienteFecha"
          class="btn-primary"
        >
          SIGUIENTE
        </button>

      </form>

      <div id="mensaje" class="mensaje"></div>

    </div>

    <script src="../js/config.js"></script>
    <script src="../js/reservas.js"></script>
  </body>
  </html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\seleccionar_hora.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seleccionar Hora - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>

  <div class="auth-container fecha-container">
    <h1>SELECCIONAR HORA</h1>
    <form id="horaForm" class="auth-form">
      <div class="input-group">
        <div id="horasGrid" class="horas-grid"></div>
        <input type="hidden" id="horaSeleccionada">
      </div>
      <button type="submit" id="btnSiguienteHora" class="btn-primary">SIGUIENTE</button>
    </form>
    <div id="mensaje" class="mensaje"></div>
  </div>
  <script src="../js/config.js"></script>
  <script src="../js/reservas.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\fronted\pages\seleccionar_servicio.html
============================
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seleccionar Servicio - ProBarberSystem</title>
  <link rel="stylesheet" href="../css/styles.css">
  <script src="../js/auth.js"></script>
</head>
<body>

  <div class="auth-container fecha-container">

    <h1>SELECCIONAR SERVICIO</h1>

    <form id="servicioForm" class="auth-form">

      <div class="input-group">
        <span>ðŸ’ˆ</span>
        <select id="servicio" required>
          <option value="" disabled selected>Selecciona un servicio</option>
          <option value="1">Corte Personalizado (12â‚¬)</option>
          <option value="2">Corte + Barba (16â‚¬)</option>
        </select>
      </div>

      <button
        type="submit"
        id="btnSiguienteServicio"
        class="btn-primary"
      >
        SIGUIENTE
      </button>

    </form>

    <div id="mensaje" class="mensaje"></div>

  </div>

  <script src="../js/config.js"></script>
  <script src="../js/reservas.js"></script>
</body>
</html>

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\pwa\manifest.json
============================
{
  "name": "ProBarberSystem",
  "short_name": "ProBarber",
  "description": "Sistema de reservas para barberÃ­a profesional",
  "start_url": "/pages/home.html",
  "display": "standalone",
  "background_color": "#2b0040",
  "theme_color": "#c44bd6",
  "icons": [
    {
      "src": "/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\pwa\service-worker.js
============================
const CACHE_NAME = 'probarber-v2'; 
const urlsToCache = [
  '/pages/home.html',
  '/pages/login.html',
  '/css/styles.css',
  '/js/login.js',
  '/js/auth.js', 
  '/js/reservas.js',
  '/images/icon-192.png',
  '/images/icon-512.png'
];

self.addEventListener('install', event => {
  console.log('ðŸ“¦ Service Worker instalando...');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('CachÃ© creado');
        return cache.addAll(urlsToCache);
      })
      .catch(err => console.error('Error creando cachÃ©:', err))
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Si estÃ¡ en cachÃ©, devolver
        if (response) {
          return response;
        }
        
        // Si no, hacer fetch y cachear si es exitoso
        return fetch(event.request).then(fetchResponse => {
          // Solo cachear respuestas vÃ¡lidas
          if (!fetchResponse || fetchResponse.status !== 200) {
            return fetchResponse;
          }
          
          const responseToCache = fetchResponse.clone();
          caches.open(CACHE_NAME).then(cache => {
            cache.put(event.request, responseToCache);
          });
          
          return fetchResponse;
        });
      })
      .catch(err => {
        console.error('Error en fetch:', err);
        // Devolver pÃ¡gina de error offline (opcional)
        return caches.match('/pages/offline.html');
      })
  );
});

// Limpiar cachÃ©s antiguos
self.addEventListener('activate', event => {
  console.log('Service Worker activado');
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            console.log('Eliminando cachÃ© antiguo:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\autoload_classmap.php
============================
<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
);

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\autoload_namespaces.php
============================
<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
);

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\autoload_psr4.php
============================
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Firebase\\JWT\\' => array($vendorDir . '/firebase/php-jwt/src'),
);

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\autoload_real.php
============================
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit20fad51902f91e7fd3039e016a6556b5
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        require __DIR__ . '/platform_check.php';

        spl_autoload_register(array('ComposerAutoloaderInit20fad51902f91e7fd3039e016a6556b5', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInit20fad51902f91e7fd3039e016a6556b5', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInit20fad51902f91e7fd3039e016a6556b5::getInitializer($loader));

        $loader->register(true);

        return $loader;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\autoload_static.php
============================
<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInit20fad51902f91e7fd3039e016a6556b5
{
    public static $prefixLengthsPsr4 = array (
        'F' =>
        array (
            'Firebase\\JWT\\' => 13,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'Firebase\\JWT\\' =>
        array (
            0 => __DIR__ . '/..' . '/firebase/php-jwt/src',
        ),
    );

    public static $classMap = array (
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInit20fad51902f91e7fd3039e016a6556b5::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInit20fad51902f91e7fd3039e016a6556b5::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInit20fad51902f91e7fd3039e016a6556b5::$classMap;

        }, null, ClassLoader::class);
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\ClassLoader.php
============================
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var \Closure(string):void */
    private static $includeFile;

    /** @var string|null */
    private $vendorDir;

    // PSR-4
    /**
     * @var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array<string, list<string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * List of PSR-0 prefixes
     *
     * Structured as array('F (first letter)' => array('Foo\Bar (full prefix)' => array('path', 'path2')))
     *
     * @var array<string, array<string, list<string>>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var array<string, bool>
     */
    private $missingClasses = array();

    /** @var string|null */
    private $apcuPrefix;

    /**
     * @var array<string, self>
     */
    private static $registeredLoaders = array();

    /**
     * @param string|null $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
        self::initializeIncludeClosure();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return array<string, string> Array of classname => path
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array<string, string> $classMap Class to filename map
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string              $prefix  The prefix
     * @param list<string>|string $paths   The PSR-0 root directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string              $prefix  The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths   The PSR-4 base directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string              $prefix The prefix
     * @param list<string>|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string              $prefix The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders keyed by their corresponding vendor directories.
     *
     * @return array<string, self>
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    /**
     * @return void
     */
    private static function initializeIncludeClosure()
    {
        if (self::$includeFile !== null) {
            return;
        }

        /**
         * Scope isolated include.
         *
         * Prevents access to $this/self from included files.
         *
         * @param  string $file
         * @return void
         */
        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\installed.json
============================
{
    "packages": [
        {
            "name": "firebase/php-jwt",
            "version": "v6.11.1",
            "version_normalized": "6.11.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "time": "2025-04-09T20:32:01+00:00",
            "type": "library",
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.11.1"
            },
            "install-path": "../firebase/php-jwt"
        }
    ],
    "dev": true,
    "dev-package-names": []
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\installed.php
============================
<?php return array(
    'root' => array(
        'name' => '__root__',
        'pretty_version' => '1.0.0+no-version-set',
        'version' => '1.0.0.0',
        'reference' => null,
        'type' => 'library',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'dev' => true,
    ),
    'versions' => array(
        '__root__' => array(
            'pretty_version' => '1.0.0+no-version-set',
            'version' => '1.0.0.0',
            'reference' => null,
            'type' => 'library',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'firebase/php-jwt' => array(
            'pretty_version' => 'v6.11.1',
            'version' => '6.11.1.0',
            'reference' => 'd1e91ecf8c598d073d0995afa8cd5c75c6e19e66',
            'type' => 'library',
            'install_path' => __DIR__ . '/../firebase/php-jwt',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
    ),
);

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\InstalledVersions.php
============================
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 *
 * @final
 */
class InstalledVersions
{
    /**
     * @var string|null if set (by reflection by Composer), this should be set to the path where this class is being copied to
     * @internal
     */
    private static $selfDir = null;

    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool
     */
    private static $installedIsLocalDir;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || !isset($installed['versions'][$packageName]['dev_requirement']) || $installed['versions'][$packageName]['dev_requirement'] === false;
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints((string) $constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();

        // when using reload, we disable the duplicate protection to ensure that self::$installed data is
        // always returned, but we cannot know whether it comes from the installed.php in __DIR__ or not,
        // so we have to assume it does not, and that may result in duplicate data being returned when listing
        // all installed packages for example
        self::$installedIsLocalDir = false;
    }

    /**
     * @return string
     */
    private static function getSelfDir()
    {
        if (self::$selfDir === null) {
            self::$selfDir = strtr(__DIR__, '\\', '/');
        }

        return self::$selfDir;
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();
        $copiedLocalDir = false;

        if (self::$canGetVendors) {
            $selfDir = self::getSelfDir();
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                $vendorDir = strtr($vendorDir, '\\', '/');
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                    $required = require $vendorDir.'/composer/installed.php';
                    self::$installedByVendor[$vendorDir] = $required;
                    $installed[] = $required;
                    if (self::$installed === null && $vendorDir.'/composer' === $selfDir) {
                        self::$installed = $required;
                        self::$installedIsLocalDir = true;
                    }
                }
                if (self::$installedIsLocalDir && $vendorDir.'/composer' === $selfDir) {
                    $copiedLocalDir = true;
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                $required = require __DIR__ . '/installed.php';
                self::$installed = $required;
            } else {
                self::$installed = array();
            }
        }

        if (self::$installed !== array() && !$copiedLocalDir) {
            $installed[] = self::$installed;
        }

        return $installed;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\composer\platform_check.php
============================
<?php

// platform_check.php @generated by Composer

$issues = array();

if (!(PHP_VERSION_ID >= 80000)) {
    $issues[] = 'Your Composer dependencies require a PHP version ">= 8.0.0". You are running ' . PHP_VERSION . '.';
}

if ($issues) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . implode(PHP_EOL, $issues) . PHP_EOL.PHP_EOL);
        } elseif (!headers_sent()) {
            echo 'Composer detected issues in your platform:' . PHP_EOL.PHP_EOL . str_replace('You are running '.PHP_VERSION.'.', '', implode(PHP_EOL, $issues)) . PHP_EOL.PHP_EOL;
        }
    }
    throw new \RuntimeException(
        'Composer detected issues in your platform: ' . implode(' ', $issues)
    );
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\BeforeValidException.php
============================
<?php

namespace Firebase\JWT;

class BeforeValidException extends \UnexpectedValueException implements JWTExceptionWithPayloadInterface
{
    private object $payload;

    public function setPayload(object $payload): void
    {
        $this->payload = $payload;
    }

    public function getPayload(): object
    {
        return $this->payload;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\CachedKeySet.php
============================
<?php

namespace Firebase\JWT;

use ArrayAccess;
use InvalidArgumentException;
use LogicException;
use OutOfBoundsException;
use Psr\Cache\CacheItemInterface;
use Psr\Cache\CacheItemPoolInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use RuntimeException;
use UnexpectedValueException;

/**
 * @implements ArrayAccess<string, Key>
 */
class CachedKeySet implements ArrayAccess
{
    /**
     * @var string
     */
    private $jwksUri;
    /**
     * @var ClientInterface
     */
    private $httpClient;
    /**
     * @var RequestFactoryInterface
     */
    private $httpFactory;
    /**
     * @var CacheItemPoolInterface
     */
    private $cache;
    /**
     * @var ?int
     */
    private $expiresAfter;
    /**
     * @var ?CacheItemInterface
     */
    private $cacheItem;
    /**
     * @var array<string, array<mixed>>
     */
    private $keySet;
    /**
     * @var string
     */
    private $cacheKey;
    /**
     * @var string
     */
    private $cacheKeyPrefix = 'jwks';
    /**
     * @var int
     */
    private $maxKeyLength = 64;
    /**
     * @var bool
     */
    private $rateLimit;
    /**
     * @var string
     */
    private $rateLimitCacheKey;
    /**
     * @var int
     */
    private $maxCallsPerMinute = 10;
    /**
     * @var string|null
     */
    private $defaultAlg;

    public function __construct(
        string $jwksUri,
        ClientInterface $httpClient,
        RequestFactoryInterface $httpFactory,
        CacheItemPoolInterface $cache,
        ?int $expiresAfter = null,
        bool $rateLimit = false,
        ?string $defaultAlg = null
    ) {
        $this->jwksUri = $jwksUri;
        $this->httpClient = $httpClient;
        $this->httpFactory = $httpFactory;
        $this->cache = $cache;
        $this->expiresAfter = $expiresAfter;
        $this->rateLimit = $rateLimit;
        $this->defaultAlg = $defaultAlg;
        $this->setCacheKeys();
    }

    /**
     * @param string $keyId
     * @return Key
     */
    public function offsetGet($keyId): Key
    {
        if (!$this->keyIdExists($keyId)) {
            throw new OutOfBoundsException('Key ID not found');
        }
        return JWK::parseKey($this->keySet[$keyId], $this->defaultAlg);
    }

    /**
     * @param string $keyId
     * @return bool
     */
    public function offsetExists($keyId): bool
    {
        return $this->keyIdExists($keyId);
    }

    /**
     * @param string $offset
     * @param Key $value
     */
    public function offsetSet($offset, $value): void
    {
        throw new LogicException('Method not implemented');
    }

    /**
     * @param string $offset
     */
    public function offsetUnset($offset): void
    {
        throw new LogicException('Method not implemented');
    }

    /**
     * @return array<mixed>
     */
    private function formatJwksForCache(string $jwks): array
    {
        $jwks = json_decode($jwks, true);

        if (!isset($jwks['keys'])) {
            throw new UnexpectedValueException('"keys" member must exist in the JWK Set');
        }

        if (empty($jwks['keys'])) {
            throw new InvalidArgumentException('JWK Set did not contain any keys');
        }

        $keys = [];
        foreach ($jwks['keys'] as $k => $v) {
            $kid = isset($v['kid']) ? $v['kid'] : $k;
            $keys[(string) $kid] = $v;
        }

        return $keys;
    }

    private function keyIdExists(string $keyId): bool
    {
        if (null === $this->keySet) {
            $item = $this->getCacheItem();
            // Try to load keys from cache
            if ($item->isHit()) {
                // item found! retrieve it
                $this->keySet = $item->get();
                // If the cached item is a string, the JWKS response was cached (previous behavior).
                // Parse this into expected format array<kid, jwk> instead.
                if (\is_string($this->keySet)) {
                    $this->keySet = $this->formatJwksForCache($this->keySet);
                }
            }
        }

        if (!isset($this->keySet[$keyId])) {
            if ($this->rateLimitExceeded()) {
                return false;
            }
            $request = $this->httpFactory->createRequest('GET', $this->jwksUri);
            $jwksResponse = $this->httpClient->sendRequest($request);
            if ($jwksResponse->getStatusCode() !== 200) {
                throw new UnexpectedValueException(
                    \sprintf('HTTP Error: %d %s for URI "%s"',
                        $jwksResponse->getStatusCode(),
                        $jwksResponse->getReasonPhrase(),
                        $this->jwksUri,
                    ),
                    $jwksResponse->getStatusCode()
                );
            }
            $this->keySet = $this->formatJwksForCache((string) $jwksResponse->getBody());

            if (!isset($this->keySet[$keyId])) {
                return false;
            }

            $item = $this->getCacheItem();
            $item->set($this->keySet);
            if ($this->expiresAfter) {
                $item->expiresAfter($this->expiresAfter);
            }
            $this->cache->save($item);
        }

        return true;
    }

    private function rateLimitExceeded(): bool
    {
        if (!$this->rateLimit) {
            return false;
        }

        $cacheItem = $this->cache->getItem($this->rateLimitCacheKey);

        $cacheItemData = [];
        if ($cacheItem->isHit() && \is_array($data = $cacheItem->get())) {
            $cacheItemData = $data;
        }

        $callsPerMinute = $cacheItemData['callsPerMinute'] ?? 0;
        $expiry = $cacheItemData['expiry'] ?? new \DateTime('+60 seconds', new \DateTimeZone('UTC'));

        if (++$callsPerMinute > $this->maxCallsPerMinute) {
            return true;
        }

        $cacheItem->set(['expiry' => $expiry, 'callsPerMinute' => $callsPerMinute]);
        $cacheItem->expiresAt($expiry);
        $this->cache->save($cacheItem);
        return false;
    }

    private function getCacheItem(): CacheItemInterface
    {
        if (\is_null($this->cacheItem)) {
            $this->cacheItem = $this->cache->getItem($this->cacheKey);
        }

        return $this->cacheItem;
    }

    private function setCacheKeys(): void
    {
        if (empty($this->jwksUri)) {
            throw new RuntimeException('JWKS URI is empty');
        }

        // ensure we do not have illegal characters
        $key = preg_replace('|[^a-zA-Z0-9_\.!]|', '', $this->jwksUri);

        // add prefix
        $key = $this->cacheKeyPrefix . $key;

        // Hash keys if they exceed $maxKeyLength of 64
        if (\strlen($key) > $this->maxKeyLength) {
            $key = substr(hash('sha256', $key), 0, $this->maxKeyLength);
        }

        $this->cacheKey = $key;

        if ($this->rateLimit) {
            // add prefix
            $rateLimitKey = $this->cacheKeyPrefix . 'ratelimit' . $key;

            // Hash keys if they exceed $maxKeyLength of 64
            if (\strlen($rateLimitKey) > $this->maxKeyLength) {
                $rateLimitKey = substr(hash('sha256', $rateLimitKey), 0, $this->maxKeyLength);
            }

            $this->rateLimitCacheKey = $rateLimitKey;
        }
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\ExpiredException.php
============================
<?php

namespace Firebase\JWT;

class ExpiredException extends \UnexpectedValueException implements JWTExceptionWithPayloadInterface
{
    private object $payload;

    public function setPayload(object $payload): void
    {
        $this->payload = $payload;
    }

    public function getPayload(): object
    {
        return $this->payload;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\JWK.php
============================
<?php

namespace Firebase\JWT;

use DomainException;
use InvalidArgumentException;
use UnexpectedValueException;

/**
 * JSON Web Key implementation, based on this spec:
 * https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41
 *
 * PHP version 5
 *
 * @category Authentication
 * @package  Authentication_JWT
 * @author   Bui Sy Nguyen <nguyenbs@gmail.com>
 * @license  http://opensource.org/licenses/BSD-3-Clause 3-clause BSD
 * @link     https://github.com/firebase/php-jwt
 */
class JWK
{
    private const OID = '1.2.840.10045.2.1';
    private const ASN1_OBJECT_IDENTIFIER = 0x06;
    private const ASN1_SEQUENCE = 0x10; // also defined in JWT
    private const ASN1_BIT_STRING = 0x03;
    private const EC_CURVES = [
        'P-256' => '1.2.840.10045.3.1.7', // Len: 64
        'secp256k1' => '1.3.132.0.10', // Len: 64
        'P-384' => '1.3.132.0.34', // Len: 96
        // 'P-521' => '1.3.132.0.35', // Len: 132 (not supported)
    ];

    // For keys with "kty" equal to "OKP" (Octet Key Pair), the "crv" parameter must contain the key subtype.
    // This library supports the following subtypes:
    private const OKP_SUBTYPES = [
        'Ed25519' => true, // RFC 8037
    ];

    /**
     * Parse a set of JWK keys
     *
     * @param array<mixed> $jwks The JSON Web Key Set as an associative array
     * @param string       $defaultAlg The algorithm for the Key object if "alg" is not set in the
     *                                 JSON Web Key Set
     *
     * @return array<string, Key> An associative array of key IDs (kid) to Key objects
     *
     * @throws InvalidArgumentException     Provided JWK Set is empty
     * @throws UnexpectedValueException     Provided JWK Set was invalid
     * @throws DomainException              OpenSSL failure
     *
     * @uses parseKey
     */
    public static function parseKeySet(array $jwks, ?string $defaultAlg = null): array
    {
        $keys = [];

        if (!isset($jwks['keys'])) {
            throw new UnexpectedValueException('"keys" member must exist in the JWK Set');
        }

        if (empty($jwks['keys'])) {
            throw new InvalidArgumentException('JWK Set did not contain any keys');
        }

        foreach ($jwks['keys'] as $k => $v) {
            $kid = isset($v['kid']) ? $v['kid'] : $k;
            if ($key = self::parseKey($v, $defaultAlg)) {
                $keys[(string) $kid] = $key;
            }
        }

        if (0 === \count($keys)) {
            throw new UnexpectedValueException('No supported algorithms found in JWK Set');
        }

        return $keys;
    }

    /**
     * Parse a JWK key
     *
     * @param array<mixed> $jwk An individual JWK
     * @param string       $defaultAlg The algorithm for the Key object if "alg" is not set in the
     *                                 JSON Web Key Set
     *
     * @return Key The key object for the JWK
     *
     * @throws InvalidArgumentException     Provided JWK is empty
     * @throws UnexpectedValueException     Provided JWK was invalid
     * @throws DomainException              OpenSSL failure
     *
     * @uses createPemFromModulusAndExponent
     */
    public static function parseKey(array $jwk, ?string $defaultAlg = null): ?Key
    {
        if (empty($jwk)) {
            throw new InvalidArgumentException('JWK must not be empty');
        }

        if (!isset($jwk['kty'])) {
            throw new UnexpectedValueException('JWK must contain a "kty" parameter');
        }

        if (!isset($jwk['alg'])) {
            if (\is_null($defaultAlg)) {
                // The "alg" parameter is optional in a KTY, but an algorithm is required
                // for parsing in this library. Use the $defaultAlg parameter when parsing the
                // key set in order to prevent this error.
                // @see https://datatracker.ietf.org/doc/html/rfc7517#section-4.4
                throw new UnexpectedValueException('JWK must contain an "alg" parameter');
            }
            $jwk['alg'] = $defaultAlg;
        }

        switch ($jwk['kty']) {
            case 'RSA':
                if (!empty($jwk['d'])) {
                    throw new UnexpectedValueException('RSA private keys are not supported');
                }
                if (!isset($jwk['n']) || !isset($jwk['e'])) {
                    throw new UnexpectedValueException('RSA keys must contain values for both "n" and "e"');
                }

                $pem = self::createPemFromModulusAndExponent($jwk['n'], $jwk['e']);
                $publicKey = \openssl_pkey_get_public($pem);
                if (false === $publicKey) {
                    throw new DomainException(
                        'OpenSSL error: ' . \openssl_error_string()
                    );
                }
                return new Key($publicKey, $jwk['alg']);
            case 'EC':
                if (isset($jwk['d'])) {
                    // The key is actually a private key
                    throw new UnexpectedValueException('Key data must be for a public key');
                }

                if (empty($jwk['crv'])) {
                    throw new UnexpectedValueException('crv not set');
                }

                if (!isset(self::EC_CURVES[$jwk['crv']])) {
                    throw new DomainException('Unrecognised or unsupported EC curve');
                }

                if (empty($jwk['x']) || empty($jwk['y'])) {
                    throw new UnexpectedValueException('x and y not set');
                }

                $publicKey = self::createPemFromCrvAndXYCoordinates($jwk['crv'], $jwk['x'], $jwk['y']);
                return new Key($publicKey, $jwk['alg']);
            case 'OKP':
                if (isset($jwk['d'])) {
                    // The key is actually a private key
                    throw new UnexpectedValueException('Key data must be for a public key');
                }

                if (!isset($jwk['crv'])) {
                    throw new UnexpectedValueException('crv not set');
                }

                if (empty(self::OKP_SUBTYPES[$jwk['crv']])) {
                    throw new DomainException('Unrecognised or unsupported OKP key subtype');
                }

                if (empty($jwk['x'])) {
                    throw new UnexpectedValueException('x not set');
                }

                // This library works internally with EdDSA keys (Ed25519) encoded in standard base64.
                $publicKey = JWT::convertBase64urlToBase64($jwk['x']);
                return new Key($publicKey, $jwk['alg']);
            case 'oct':
                if (!isset($jwk['k'])) {
                    throw new UnexpectedValueException('k not set');
                }

                return new Key(JWT::urlsafeB64Decode($jwk['k']), $jwk['alg']);
            default:
                break;
        }

        return null;
    }

    /**
     * Converts the EC JWK values to pem format.
     *
     * @param   string  $crv The EC curve (only P-256 & P-384 is supported)
     * @param   string  $x   The EC x-coordinate
     * @param   string  $y   The EC y-coordinate
     *
     * @return  string
     */
    private static function createPemFromCrvAndXYCoordinates(string $crv, string $x, string $y): string
    {
        $pem =
            self::encodeDER(
                self::ASN1_SEQUENCE,
                self::encodeDER(
                    self::ASN1_SEQUENCE,
                    self::encodeDER(
                        self::ASN1_OBJECT_IDENTIFIER,
                        self::encodeOID(self::OID)
                    )
                    . self::encodeDER(
                        self::ASN1_OBJECT_IDENTIFIER,
                        self::encodeOID(self::EC_CURVES[$crv])
                    )
                ) .
                self::encodeDER(
                    self::ASN1_BIT_STRING,
                    \chr(0x00) . \chr(0x04)
                    . JWT::urlsafeB64Decode($x)
                    . JWT::urlsafeB64Decode($y)
                )
            );

        return \sprintf(
            "-----BEGIN PUBLIC KEY-----\n%s\n-----END PUBLIC KEY-----\n",
            wordwrap(base64_encode($pem), 64, "\n", true)
        );
    }

    /**
     * Create a public key represented in PEM format from RSA modulus and exponent information
     *
     * @param string $n The RSA modulus encoded in Base64
     * @param string $e The RSA exponent encoded in Base64
     *
     * @return string The RSA public key represented in PEM format
     *
     * @uses encodeLength
     */
    private static function createPemFromModulusAndExponent(
        string $n,
        string $e
    ): string {
        $mod = JWT::urlsafeB64Decode($n);
        $exp = JWT::urlsafeB64Decode($e);

        $modulus = \pack('Ca*a*', 2, self::encodeLength(\strlen($mod)), $mod);
        $publicExponent = \pack('Ca*a*', 2, self::encodeLength(\strlen($exp)), $exp);

        $rsaPublicKey = \pack(
            'Ca*a*a*',
            48,
            self::encodeLength(\strlen($modulus) + \strlen($publicExponent)),
            $modulus,
            $publicExponent
        );

        // sequence(oid(1.2.840.113549.1.1.1), null)) = rsaEncryption.
        $rsaOID = \pack('H*', '300d06092a864886f70d0101010500'); // hex version of MA0GCSqGSIb3DQEBAQUA
        $rsaPublicKey = \chr(0) . $rsaPublicKey;
        $rsaPublicKey = \chr(3) . self::encodeLength(\strlen($rsaPublicKey)) . $rsaPublicKey;

        $rsaPublicKey = \pack(
            'Ca*a*',
            48,
            self::encodeLength(\strlen($rsaOID . $rsaPublicKey)),
            $rsaOID . $rsaPublicKey
        );

        return "-----BEGIN PUBLIC KEY-----\r\n" .
            \chunk_split(\base64_encode($rsaPublicKey), 64) .
            '-----END PUBLIC KEY-----';
    }

    /**
     * DER-encode the length
     *
     * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
     * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
     *
     * @param int $length
     * @return string
     */
    private static function encodeLength(int $length): string
    {
        if ($length <= 0x7F) {
            return \chr($length);
        }

        $temp = \ltrim(\pack('N', $length), \chr(0));

        return \pack('Ca*', 0x80 | \strlen($temp), $temp);
    }

    /**
     * Encodes a value into a DER object.
     * Also defined in Firebase\JWT\JWT
     *
     * @param   int     $type DER tag
     * @param   string  $value the value to encode
     * @return  string  the encoded object
     */
    private static function encodeDER(int $type, string $value): string
    {
        $tag_header = 0;
        if ($type === self::ASN1_SEQUENCE) {
            $tag_header |= 0x20;
        }

        // Type
        $der = \chr($tag_header | $type);

        // Length
        $der .= \chr(\strlen($value));

        return $der . $value;
    }

    /**
     * Encodes a string into a DER-encoded OID.
     *
     * @param   string $oid the OID string
     * @return  string the binary DER-encoded OID
     */
    private static function encodeOID(string $oid): string
    {
        $octets = explode('.', $oid);

        // Get the first octet
        $first = (int) array_shift($octets);
        $second = (int) array_shift($octets);
        $oid = \chr($first * 40 + $second);

        // Iterate over subsequent octets
        foreach ($octets as $octet) {
            if ($octet == 0) {
                $oid .= \chr(0x00);
                continue;
            }
            $bin = '';

            while ($octet) {
                $bin .= \chr(0x80 | ($octet & 0x7f));
                $octet >>= 7;
            }
            $bin[0] = $bin[0] & \chr(0x7f);

            // Convert to big endian if necessary
            if (pack('V', 65534) == pack('L', 65534)) {
                $oid .= strrev($bin);
            } else {
                $oid .= $bin;
            }
        }

        return $oid;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\JWT.php
============================
<?php

namespace Firebase\JWT;

use ArrayAccess;
use DateTime;
use DomainException;
use Exception;
use InvalidArgumentException;
use OpenSSLAsymmetricKey;
use OpenSSLCertificate;
use stdClass;
use UnexpectedValueException;

/**
 * JSON Web Token implementation, based on this spec:
 * https://tools.ietf.org/html/rfc7519
 *
 * PHP version 5
 *
 * @category Authentication
 * @package  Authentication_JWT
 * @author   Neuman Vong <neuman@twilio.com>
 * @author   Anant Narayanan <anant@php.net>
 * @license  http://opensource.org/licenses/BSD-3-Clause 3-clause BSD
 * @link     https://github.com/firebase/php-jwt
 */
class JWT
{
    private const ASN1_INTEGER = 0x02;
    private const ASN1_SEQUENCE = 0x10;
    private const ASN1_BIT_STRING = 0x03;

    /**
     * When checking nbf, iat or expiration times,
     * we want to provide some extra leeway time to
     * account for clock skew.
     *
     * @var int
     */
    public static $leeway = 0;

    /**
     * Allow the current timestamp to be specified.
     * Useful for fixing a value within unit testing.
     * Will default to PHP time() value if null.
     *
     * @var ?int
     */
    public static $timestamp = null;

    /**
     * @var array<string, string[]>
     */
    public static $supported_algs = [
        'ES384' => ['openssl', 'SHA384'],
        'ES256' => ['openssl', 'SHA256'],
        'ES256K' => ['openssl', 'SHA256'],
        'HS256' => ['hash_hmac', 'SHA256'],
        'HS384' => ['hash_hmac', 'SHA384'],
        'HS512' => ['hash_hmac', 'SHA512'],
        'RS256' => ['openssl', 'SHA256'],
        'RS384' => ['openssl', 'SHA384'],
        'RS512' => ['openssl', 'SHA512'],
        'EdDSA' => ['sodium_crypto', 'EdDSA'],
    ];

    /**
     * Decodes a JWT string into a PHP object.
     *
     * @param string                 $jwt            The JWT
     * @param Key|ArrayAccess<string,Key>|array<string,Key> $keyOrKeyArray  The Key or associative array of key IDs
     *                                                                      (kid) to Key objects.
     *                                                                      If the algorithm used is asymmetric, this is
     *                                                                      the public key.
     *                                                                      Each Key object contains an algorithm and
     *                                                                      matching key.
     *                                                                      Supported algorithms are 'ES384','ES256',
     *                                                                      'HS256', 'HS384', 'HS512', 'RS256', 'RS384'
     *                                                                      and 'RS512'.
     * @param stdClass               $headers                               Optional. Populates stdClass with headers.
     *
     * @return stdClass The JWT's payload as a PHP object
     *
     * @throws InvalidArgumentException     Provided key/key-array was empty or malformed
     * @throws DomainException              Provided JWT is malformed
     * @throws UnexpectedValueException     Provided JWT was invalid
     * @throws SignatureInvalidException    Provided JWT was invalid because the signature verification failed
     * @throws BeforeValidException         Provided JWT is trying to be used before it's eligible as defined by 'nbf'
     * @throws BeforeValidException         Provided JWT is trying to be used before it's been created as defined by 'iat'
     * @throws ExpiredException             Provided JWT has since expired, as defined by the 'exp' claim
     *
     * @uses jsonDecode
     * @uses urlsafeB64Decode
     */
    public static function decode(
        string $jwt,
        $keyOrKeyArray,
        ?stdClass &$headers = null
    ): stdClass {
        // Validate JWT
        $timestamp = \is_null(static::$timestamp) ? \time() : static::$timestamp;

        if (empty($keyOrKeyArray)) {
            throw new InvalidArgumentException('Key may not be empty');
        }
        $tks = \explode('.', $jwt);
        if (\count($tks) !== 3) {
            throw new UnexpectedValueException('Wrong number of segments');
        }
        list($headb64, $bodyb64, $cryptob64) = $tks;
        $headerRaw = static::urlsafeB64Decode($headb64);
        if (null === ($header = static::jsonDecode($headerRaw))) {
            throw new UnexpectedValueException('Invalid header encoding');
        }
        if ($headers !== null) {
            $headers = $header;
        }
        $payloadRaw = static::urlsafeB64Decode($bodyb64);
        if (null === ($payload = static::jsonDecode($payloadRaw))) {
            throw new UnexpectedValueException('Invalid claims encoding');
        }
        if (\is_array($payload)) {
            // prevent PHP Fatal Error in edge-cases when payload is empty array
            $payload = (object) $payload;
        }
        if (!$payload instanceof stdClass) {
            throw new UnexpectedValueException('Payload must be a JSON object');
        }
        $sig = static::urlsafeB64Decode($cryptob64);
        if (empty($header->alg)) {
            throw new UnexpectedValueException('Empty algorithm');
        }
        if (empty(static::$supported_algs[$header->alg])) {
            throw new UnexpectedValueException('Algorithm not supported');
        }

        $key = self::getKey($keyOrKeyArray, property_exists($header, 'kid') ? $header->kid : null);

        // Check the algorithm
        if (!self::constantTimeEquals($key->getAlgorithm(), $header->alg)) {
            // See issue #351
            throw new UnexpectedValueException('Incorrect key for this algorithm');
        }
        if (\in_array($header->alg, ['ES256', 'ES256K', 'ES384'], true)) {
            // OpenSSL expects an ASN.1 DER sequence for ES256/ES256K/ES384 signatures
            $sig = self::signatureToDER($sig);
        }
        if (!self::verify("{$headb64}.{$bodyb64}", $sig, $key->getKeyMaterial(), $header->alg)) {
            throw new SignatureInvalidException('Signature verification failed');
        }

        // Check the nbf if it is defined. This is the time that the
        // token can actually be used. If it's not yet that time, abort.
        if (isset($payload->nbf) && floor($payload->nbf) > ($timestamp + static::$leeway)) {
            $ex = new BeforeValidException(
                'Cannot handle token with nbf prior to ' . \date(DateTime::ISO8601, (int) floor($payload->nbf))
            );
            $ex->setPayload($payload);
            throw $ex;
        }

        // Check that this token has been created before 'now'. This prevents
        // using tokens that have been created for later use (and haven't
        // correctly used the nbf claim).
        if (!isset($payload->nbf) && isset($payload->iat) && floor($payload->iat) > ($timestamp + static::$leeway)) {
            $ex = new BeforeValidException(
                'Cannot handle token with iat prior to ' . \date(DateTime::ISO8601, (int) floor($payload->iat))
            );
            $ex->setPayload($payload);
            throw $ex;
        }

        // Check if this token has expired.
        if (isset($payload->exp) && ($timestamp - static::$leeway) >= $payload->exp) {
            $ex = new ExpiredException('Expired token');
            $ex->setPayload($payload);
            throw $ex;
        }

        return $payload;
    }

    /**
     * Converts and signs a PHP array into a JWT string.
     *
     * @param array<mixed>          $payload PHP array
     * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate $key The secret key.
     * @param string                $alg     Supported algorithms are 'ES384','ES256', 'ES256K', 'HS256',
     *                                       'HS384', 'HS512', 'RS256', 'RS384', and 'RS512'
     * @param string                $keyId
     * @param array<string, string> $head    An array with header elements to attach
     *
     * @return string A signed JWT
     *
     * @uses jsonEncode
     * @uses urlsafeB64Encode
     */
    public static function encode(
        array $payload,
        $key,
        string $alg,
        ?string $keyId = null,
        ?array $head = null
    ): string {
        $header = ['typ' => 'JWT'];
        if (isset($head)) {
            $header = \array_merge($header, $head);
        }
        $header['alg'] = $alg;
        if ($keyId !== null) {
            $header['kid'] = $keyId;
        }
        $segments = [];
        $segments[] = static::urlsafeB64Encode((string) static::jsonEncode($header));
        $segments[] = static::urlsafeB64Encode((string) static::jsonEncode($payload));
        $signing_input = \implode('.', $segments);

        $signature = static::sign($signing_input, $key, $alg);
        $segments[] = static::urlsafeB64Encode($signature);

        return \implode('.', $segments);
    }

    /**
     * Sign a string with a given key and algorithm.
     *
     * @param string $msg  The message to sign
     * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate  $key  The secret key.
     * @param string $alg  Supported algorithms are 'EdDSA', 'ES384', 'ES256', 'ES256K', 'HS256',
     *                    'HS384', 'HS512', 'RS256', 'RS384', and 'RS512'
     *
     * @return string An encrypted message
     *
     * @throws DomainException Unsupported algorithm or bad key was specified
     */
    public static function sign(
        string $msg,
        $key,
        string $alg
    ): string {
        if (empty(static::$supported_algs[$alg])) {
            throw new DomainException('Algorithm not supported');
        }
        list($function, $algorithm) = static::$supported_algs[$alg];
        switch ($function) {
            case 'hash_hmac':
                if (!\is_string($key)) {
                    throw new InvalidArgumentException('key must be a string when using hmac');
                }
                return \hash_hmac($algorithm, $msg, $key, true);
            case 'openssl':
                $signature = '';
                if (!\is_resource($key) && !openssl_pkey_get_private($key)) {
                    throw new DomainException('OpenSSL unable to validate key');
                }
                $success = \openssl_sign($msg, $signature, $key, $algorithm); // @phpstan-ignore-line
                if (!$success) {
                    throw new DomainException('OpenSSL unable to sign data');
                }
                if ($alg === 'ES256' || $alg === 'ES256K') {
                    $signature = self::signatureFromDER($signature, 256);
                } elseif ($alg === 'ES384') {
                    $signature = self::signatureFromDER($signature, 384);
                }
                return $signature;
            case 'sodium_crypto':
                if (!\function_exists('sodium_crypto_sign_detached')) {
                    throw new DomainException('libsodium is not available');
                }
                if (!\is_string($key)) {
                    throw new InvalidArgumentException('key must be a string when using EdDSA');
                }
                try {
                    // The last non-empty line is used as the key.
                    $lines = array_filter(explode("\n", $key));
                    $key = base64_decode((string) end($lines));
                    if (\strlen($key) === 0) {
                        throw new DomainException('Key cannot be empty string');
                    }
                    return sodium_crypto_sign_detached($msg, $key);
                } catch (Exception $e) {
                    throw new DomainException($e->getMessage(), 0, $e);
                }
        }

        throw new DomainException('Algorithm not supported');
    }

    /**
     * Verify a signature with the message, key and method. Not all methods
     * are symmetric, so we must have a separate verify and sign method.
     *
     * @param string $msg         The original message (header and body)
     * @param string $signature   The original signature
     * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate  $keyMaterial For Ed*, ES*, HS*, a string key works. for RS*, must be an instance of OpenSSLAsymmetricKey
     * @param string $alg         The algorithm
     *
     * @return bool
     *
     * @throws DomainException Invalid Algorithm, bad key, or OpenSSL failure
     */
    private static function verify(
        string $msg,
        string $signature,
        $keyMaterial,
        string $alg
    ): bool {
        if (empty(static::$supported_algs[$alg])) {
            throw new DomainException('Algorithm not supported');
        }

        list($function, $algorithm) = static::$supported_algs[$alg];
        switch ($function) {
            case 'openssl':
                $success = \openssl_verify($msg, $signature, $keyMaterial, $algorithm); // @phpstan-ignore-line
                if ($success === 1) {
                    return true;
                }
                if ($success === 0) {
                    return false;
                }
                // returns 1 on success, 0 on failure, -1 on error.
                throw new DomainException(
                    'OpenSSL error: ' . \openssl_error_string()
                );
            case 'sodium_crypto':
                if (!\function_exists('sodium_crypto_sign_verify_detached')) {
                    throw new DomainException('libsodium is not available');
                }
                if (!\is_string($keyMaterial)) {
                    throw new InvalidArgumentException('key must be a string when using EdDSA');
                }
                try {
                    // The last non-empty line is used as the key.
                    $lines = array_filter(explode("\n", $keyMaterial));
                    $key = base64_decode((string) end($lines));
                    if (\strlen($key) === 0) {
                        throw new DomainException('Key cannot be empty string');
                    }
                    if (\strlen($signature) === 0) {
                        throw new DomainException('Signature cannot be empty string');
                    }
                    return sodium_crypto_sign_verify_detached($signature, $msg, $key);
                } catch (Exception $e) {
                    throw new DomainException($e->getMessage(), 0, $e);
                }
            case 'hash_hmac':
            default:
                if (!\is_string($keyMaterial)) {
                    throw new InvalidArgumentException('key must be a string when using hmac');
                }
                $hash = \hash_hmac($algorithm, $msg, $keyMaterial, true);
                return self::constantTimeEquals($hash, $signature);
        }
    }

    /**
     * Decode a JSON string into a PHP object.
     *
     * @param string $input JSON string
     *
     * @return mixed The decoded JSON string
     *
     * @throws DomainException Provided string was invalid JSON
     */
    public static function jsonDecode(string $input)
    {
        $obj = \json_decode($input, false, 512, JSON_BIGINT_AS_STRING);

        if ($errno = \json_last_error()) {
            self::handleJsonError($errno);
        } elseif ($obj === null && $input !== 'null') {
            throw new DomainException('Null result with non-null input');
        }
        return $obj;
    }

    /**
     * Encode a PHP array into a JSON string.
     *
     * @param array<mixed> $input A PHP array
     *
     * @return string JSON representation of the PHP array
     *
     * @throws DomainException Provided object could not be encoded to valid JSON
     */
    public static function jsonEncode(array $input): string
    {
        $json = \json_encode($input, \JSON_UNESCAPED_SLASHES);
        if ($errno = \json_last_error()) {
            self::handleJsonError($errno);
        } elseif ($json === 'null') {
            throw new DomainException('Null result with non-null input');
        }
        if ($json === false) {
            throw new DomainException('Provided object could not be encoded to valid JSON');
        }
        return $json;
    }

    /**
     * Decode a string with URL-safe Base64.
     *
     * @param string $input A Base64 encoded string
     *
     * @return string A decoded string
     *
     * @throws InvalidArgumentException invalid base64 characters
     */
    public static function urlsafeB64Decode(string $input): string
    {
        return \base64_decode(self::convertBase64UrlToBase64($input));
    }

    /**
     * Convert a string in the base64url (URL-safe Base64) encoding to standard base64.
     *
     * @param string $input A Base64 encoded string with URL-safe characters (-_ and no padding)
     *
     * @return string A Base64 encoded string with standard characters (+/) and padding (=), when
     * needed.
     *
     * @see https://www.rfc-editor.org/rfc/rfc4648
     */
    public static function convertBase64UrlToBase64(string $input): string
    {
        $remainder = \strlen($input) % 4;
        if ($remainder) {
            $padlen = 4 - $remainder;
            $input .= \str_repeat('=', $padlen);
        }
        return \strtr($input, '-_', '+/');
    }

    /**
     * Encode a string with URL-safe Base64.
     *
     * @param string $input The string you want encoded
     *
     * @return string The base64 encode of what you passed in
     */
    public static function urlsafeB64Encode(string $input): string
    {
        return \str_replace('=', '', \strtr(\base64_encode($input), '+/', '-_'));
    }


    /**
     * Determine if an algorithm has been provided for each Key
     *
     * @param Key|ArrayAccess<string,Key>|array<string,Key> $keyOrKeyArray
     * @param string|null            $kid
     *
     * @throws UnexpectedValueException
     *
     * @return Key
     */
    private static function getKey(
        $keyOrKeyArray,
        ?string $kid
    ): Key {
        if ($keyOrKeyArray instanceof Key) {
            return $keyOrKeyArray;
        }

        if (empty($kid) && $kid !== '0') {
            throw new UnexpectedValueException('"kid" empty, unable to lookup correct key');
        }

        if ($keyOrKeyArray instanceof CachedKeySet) {
            // Skip "isset" check, as this will automatically refresh if not set
            return $keyOrKeyArray[$kid];
        }

        if (!isset($keyOrKeyArray[$kid])) {
            throw new UnexpectedValueException('"kid" invalid, unable to lookup correct key');
        }

        return $keyOrKeyArray[$kid];
    }

    /**
     * @param string $left  The string of known length to compare against
     * @param string $right The user-supplied string
     * @return bool
     */
    public static function constantTimeEquals(string $left, string $right): bool
    {
        if (\function_exists('hash_equals')) {
            return \hash_equals($left, $right);
        }
        $len = \min(self::safeStrlen($left), self::safeStrlen($right));

        $status = 0;
        for ($i = 0; $i < $len; $i++) {
            $status |= (\ord($left[$i]) ^ \ord($right[$i]));
        }
        $status |= (self::safeStrlen($left) ^ self::safeStrlen($right));

        return ($status === 0);
    }

    /**
     * Helper method to create a JSON error.
     *
     * @param int $errno An error number from json_last_error()
     *
     * @throws DomainException
     *
     * @return void
     */
    private static function handleJsonError(int $errno): void
    {
        $messages = [
            JSON_ERROR_DEPTH => 'Maximum stack depth exceeded',
            JSON_ERROR_STATE_MISMATCH => 'Invalid or malformed JSON',
            JSON_ERROR_CTRL_CHAR => 'Unexpected control character found',
            JSON_ERROR_SYNTAX => 'Syntax error, malformed JSON',
            JSON_ERROR_UTF8 => 'Malformed UTF-8 characters' //PHP >= 5.3.3
        ];
        throw new DomainException(
            isset($messages[$errno])
            ? $messages[$errno]
            : 'Unknown JSON error: ' . $errno
        );
    }

    /**
     * Get the number of bytes in cryptographic strings.
     *
     * @param string $str
     *
     * @return int
     */
    private static function safeStrlen(string $str): int
    {
        if (\function_exists('mb_strlen')) {
            return \mb_strlen($str, '8bit');
        }
        return \strlen($str);
    }

    /**
     * Convert an ECDSA signature to an ASN.1 DER sequence
     *
     * @param   string $sig The ECDSA signature to convert
     * @return  string The encoded DER object
     */
    private static function signatureToDER(string $sig): string
    {
        // Separate the signature into r-value and s-value
        $length = max(1, (int) (\strlen($sig) / 2));
        list($r, $s) = \str_split($sig, $length);

        // Trim leading zeros
        $r = \ltrim($r, "\x00");
        $s = \ltrim($s, "\x00");

        // Convert r-value and s-value from unsigned big-endian integers to
        // signed two's complement
        if (\ord($r[0]) > 0x7f) {
            $r = "\x00" . $r;
        }
        if (\ord($s[0]) > 0x7f) {
            $s = "\x00" . $s;
        }

        return self::encodeDER(
            self::ASN1_SEQUENCE,
            self::encodeDER(self::ASN1_INTEGER, $r) .
            self::encodeDER(self::ASN1_INTEGER, $s)
        );
    }

    /**
     * Encodes a value into a DER object.
     *
     * @param   int     $type DER tag
     * @param   string  $value the value to encode
     *
     * @return  string  the encoded object
     */
    private static function encodeDER(int $type, string $value): string
    {
        $tag_header = 0;
        if ($type === self::ASN1_SEQUENCE) {
            $tag_header |= 0x20;
        }

        // Type
        $der = \chr($tag_header | $type);

        // Length
        $der .= \chr(\strlen($value));

        return $der . $value;
    }

    /**
     * Encodes signature from a DER object.
     *
     * @param   string  $der binary signature in DER format
     * @param   int     $keySize the number of bits in the key
     *
     * @return  string  the signature
     */
    private static function signatureFromDER(string $der, int $keySize): string
    {
        // OpenSSL returns the ECDSA signatures as a binary ASN.1 DER SEQUENCE
        list($offset, $_) = self::readDER($der);
        list($offset, $r) = self::readDER($der, $offset);
        list($offset, $s) = self::readDER($der, $offset);

        // Convert r-value and s-value from signed two's compliment to unsigned
        // big-endian integers
        $r = \ltrim($r, "\x00");
        $s = \ltrim($s, "\x00");

        // Pad out r and s so that they are $keySize bits long
        $r = \str_pad($r, $keySize / 8, "\x00", STR_PAD_LEFT);
        $s = \str_pad($s, $keySize / 8, "\x00", STR_PAD_LEFT);

        return $r . $s;
    }

    /**
     * Reads binary DER-encoded data and decodes into a single object
     *
     * @param string $der the binary data in DER format
     * @param int $offset the offset of the data stream containing the object
     * to decode
     *
     * @return array{int, string|null} the new offset and the decoded object
     */
    private static function readDER(string $der, int $offset = 0): array
    {
        $pos = $offset;
        $size = \strlen($der);
        $constructed = (\ord($der[$pos]) >> 5) & 0x01;
        $type = \ord($der[$pos++]) & 0x1f;

        // Length
        $len = \ord($der[$pos++]);
        if ($len & 0x80) {
            $n = $len & 0x1f;
            $len = 0;
            while ($n-- && $pos < $size) {
                $len = ($len << 8) | \ord($der[$pos++]);
            }
        }

        // Value
        if ($type === self::ASN1_BIT_STRING) {
            $pos++; // Skip the first contents octet (padding indicator)
            $data = \substr($der, $pos, $len - 1);
            $pos += $len - 1;
        } elseif (!$constructed) {
            $data = \substr($der, $pos, $len);
            $pos += $len;
        } else {
            $data = null;
        }

        return [$pos, $data];
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\JWTExceptionWithPayloadInterface.php
============================
<?php
namespace Firebase\JWT;

interface JWTExceptionWithPayloadInterface
{
    /**
     * Get the payload that caused this exception.
     *
     * @return object
     */
    public function getPayload(): object;

    /**
     * Get the payload that caused this exception.
     *
     * @param object $payload
     * @return void
     */
    public function setPayload(object $payload): void;
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\Key.php
============================
<?php

namespace Firebase\JWT;

use InvalidArgumentException;
use OpenSSLAsymmetricKey;
use OpenSSLCertificate;
use TypeError;

class Key
{
    /**
     * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate $keyMaterial
     * @param string $algorithm
     */
    public function __construct(
        private $keyMaterial,
        private string $algorithm
    ) {
        if (
            !\is_string($keyMaterial)
            && !$keyMaterial instanceof OpenSSLAsymmetricKey
            && !$keyMaterial instanceof OpenSSLCertificate
            && !\is_resource($keyMaterial)
        ) {
            throw new TypeError('Key material must be a string, resource, or OpenSSLAsymmetricKey');
        }

        if (empty($keyMaterial)) {
            throw new InvalidArgumentException('Key material must not be empty');
        }

        if (empty($algorithm)) {
            throw new InvalidArgumentException('Algorithm must not be empty');
        }
    }

    /**
     * Return the algorithm valid for this key
     *
     * @return string
     */
    public function getAlgorithm(): string
    {
        return $this->algorithm;
    }

    /**
     * @return string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate
     */
    public function getKeyMaterial()
    {
        return $this->keyMaterial;
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\src\SignatureInvalidException.php
============================
<?php

namespace Firebase\JWT;

class SignatureInvalidException extends \UnexpectedValueException
{
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\firebase\php-jwt\composer.json
============================
{
    "name": "firebase/php-jwt",
    "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
    "homepage": "https://github.com/firebase/php-jwt",
    "keywords": [
        "php",
        "jwt"
    ],
    "authors": [
        {
            "name": "Neuman Vong",
            "email": "neuman+pear@twilio.com",
            "role": "Developer"
        },
        {
            "name": "Anant Narayanan",
            "email": "anant@php.net",
            "role": "Developer"
        }
    ],
    "license": "BSD-3-Clause",
    "require": {
        "php": "^8.0"
    },
    "suggest": {
        "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present",
        "ext-sodium": "Support EdDSA (Ed25519) signatures"
    },
    "autoload": {
        "psr-4": {
            "Firebase\\JWT\\": "src"
        }
    },
    "require-dev": {
        "guzzlehttp/guzzle": "^7.4",
        "phpspec/prophecy-phpunit": "^2.0",
        "phpunit/phpunit": "^9.5",
        "psr/cache": "^2.0||^3.0",
        "psr/http-client": "^1.0",
        "psr/http-factory": "^1.0"
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\vendor\autoload.php
============================
<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 50600) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.'.PHP_EOL;
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, $err);
        } elseif (!headers_sent()) {
            echo $err;
        }
    }
    throw new RuntimeException($err);
}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit20fad51902f91e7fd3039e016a6556b5::getLoader();

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\composer.json
============================
{
    "require": {
        "firebase/php-jwt": "^6.11"
    }
}

============================
ARCHIVO: C:\xampp\htdocs\ProBarberSystem\composer.lock
============================
{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "726b0a650f3a35c706f5a399d9e99662",
    "packages": [
        {
            "name": "firebase/php-jwt",
            "version": "v6.11.1",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.11.1"
            },
            "time": "2025-04-09T20:32:01+00:00"
        }
    ],
    "packages-dev": [],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": {},
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": {},
    "platform-dev": {},
    "plugin-api-version": "2.9.0"
}

